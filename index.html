<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Mississippi Ambient Air Quality Data and Forecast - Real-time air quality information from MDEQ">
    <meta name="keywords" content="Mississippi, air quality, AQI, forecast, pollution, MDEQ, ozone, PM2.5">
    <title>Mississippi Air Quality Dashboard</title>
 <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" crossorigin=""/>
    <link rel="stylesheet" href="/Users/rodneycuevas/Library/CloudStorage/OneDrive-MississippiDepartmentofEnvironmentalQuality/Documents/Github/Webpage/styles.css">
    <style>
        :root {
            --good-color: #00e400;
            --moderate-color: #ffff00;
            --unhealthy-sensitive-color: #ff7e00;
            --unhealthy-color: #ff0000;
            --very-unhealthy-color: #99004c;
            --hazardous-color: #7e0023;
            --primary-color: #0071bc;
            --secondary-color: #f0f0f0;
            --text-color: #333;
            --link-color: #0056b3;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            margin: 0;
            padding: 0;
            background-color: #f9f9f9;
        }

        .custom-popup .leaflet-popup-content {
            max-height: 400px;
            overflow-y: auto;
            margin: 10px;
        }

        .custom-popup .leaflet-popup-content-wrapper {
            border-radius: 8px;
        }

        .custom-popup canvas {
            max-height: 180px;  /* Smaller chart height */
        }
        
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: var(--primary-color);
            color: white;
            padding: 1rem 2rem;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        header h1 {
            margin: 0;
            font-size: 1.8rem;
        }
        
        main {
            max-width: 1200px;
            margin: 0 auto;
            padding: 1rem;
        }
        
        footer {
            background-color: var(--secondary-color);
            text-align: center;
            padding: 1rem;
            margin-top: 2rem;
            font-size: 0.9rem;
        }
        
        .tab {
            display: flex;
            flex-wrap: wrap;
            background-color: var(--secondary-color);
            border-radius: 5px 5px 0 0;
            overflow: hidden;
        }
        
        .tab button, .tab a {
            flex-grow: 1;
            background-color: inherit;
            border: none;
            outline: none;
            cursor: pointer;
            padding: 14px 16px;
            transition: all 0.3s;
            font-weight: 600;
            text-align: center;
        }
        
        .tab a {
            display: block;
            text-decoration: none;
            color: var(--text-color);
        }
        
        .tab button:hover, .tab a:hover {
            background-color: #ddd;
        }
        
        .tab button.active {
            background-color: white;
            border-bottom: 3px solid var(--primary-color);
        }
        
        .tabcontent {
            display: none;
            padding: 20px;
            border: 1px solid #ccc;
            border-top: none;
            border-radius: 0 0 5px 5px;
            background-color: white;
            animation: fadeEffect 1s;
        }
        
        @keyframes fadeEffect {
            from {opacity: 0;}
            to {opacity: 1;}
        }
        
        #map, #historical-map {
            height: 600px;
            margin: 1rem 0;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .chart-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            margin: 2rem 0;
        }
        
        canvas {
            max-width: 800px;
            max-height: 400px;
            margin: 1rem 0;
        }
        
        select {
            padding: 8px;
            margin: 1rem 0;
            border-radius: 4px;
            border: 1px solid #ddd;
            font-size: 1rem;
        }
        
        label {
            font-weight: 600;
            margin-right: 10px;
        }
        
        .forecast-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            margin-top: 20px;
        }
        
        .forecast-item {
            border-radius: 5px;
            padding: 15px;
            margin: 10px;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            flex: 1 1 250px;
            max-width: 300px;
            color: #333;
        }
        
        .forecast-item h3 {
            margin-top: 0;
        }
        
        .forecast-item.good {
            background-color: var(--good-color);
        }
        
        .forecast-item.moderate {
            background-color: var(--moderate-color);
        }
        
        .forecast-item.unhealthy-for-sensitive-groups {
            background-color: var(--unhealthy-sensitive-color);
            color: white;
        }
        
        .forecast-item.unhealthy {
            background-color: var(--unhealthy-color);
            color: white;
        }
        
        .forecast-item.very-unhealthy {
            background-color: var(--very-unhealthy-color);
            color: white;
        }
        
        .forecast-item.hazardous {
            background-color: var(--hazardous-color);
            color: white;
        }
        
        .aqi-legend {
            margin: 1rem 0;
            padding: 1rem;
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .aqi-legend h3 {
            margin-top: 0;
        }
        
        .aqi-legend-items {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
        }
        
        .aqi-legend-item {
            display: flex;
            align-items: center;
            margin: 5px 10px;
        }
        
        .aqi-color {
            width: 20px;
            height: 20px;
            margin-right: 5px;
            border-radius: 3px;
        }
        
        .loader {
            display: none;
            text-align: center;
            padding: 20px;
        }
        
        .loader::after {
            content: "";
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .error-message {
            display: none;
            color: red;
            background-color: #ffeeee;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            margin: 10px 0;
        }
        
        .share-button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin: 10px 0;
            display: flex;
            align-items: center;
        }
        
        .share-button:hover {
            background-color: var(--link-color);
        }
        
        .date-selector {
            display: flex;
            align-items: center;
            margin: 1rem 0;
        }
        
        .date-selector input {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ddd;
            margin-right: 10px;
        }
        
        /* New styles for historical trends features */
        .date-range-selector {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            background-color: var(--secondary-color);
            padding: 15px;
            border-radius: 5px;
            margin: 1rem 0;
        }

        .date-range-selector label {
            margin-right: 8px;
            margin-left: 15px;
            font-weight: 600;
        }

        .date-range-selector input[type="date"],
        .date-range-selector select {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ddd;
            margin-right: 15px;
        }

        .analysis-container {
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            padding: 20px;
            margin-top: 20px;
        }

        .parameter-statistics h4,
        .parameter-exceedance h4 {
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 8px;
            margin-bottom: 15px;
            color: var(--primary-color);
        }

        .category-bars {
            margin: 15px 0;
        }

        .category-label {
            margin-bottom: 3px;
            font-size: 0.9rem;
        }

        .category-bar {
            border-radius: 3px;
            transition: width 0.5s ease;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        @media screen and (max-width: 768px) {
            header {
                flex-direction: column;
                text-align: center;
                padding: 1rem;
            }
            
            header img {
                margin-top: 10px;
            }
            
            #map, #historical-map {
                height: 400px;
            }
            
            .forecast-item {
                flex: 1 1 100%;
                margin: 10px 0;
            }
            
            .tab button, .tab a {
                font-size: 0.9rem;
                padding: 10px;
            }
            
            .aqi-legend-items {
                flex-direction: column;
            }
            
            .date-range-selector {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .date-range-selector label {
                margin-top: 10px;
                margin-left: 0;
            }
            
            .date-range-selector input[type="date"],
            .date-range-selector select {
                width: 100%;
                margin-right: 0;
                margin-bottom: 10px;
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Mississippi Ambient Air Quality Dashboard</h1>
        <a href="https://www.mdeq.ms.gov/" target="_blank" rel="noopener noreferrer">
            <!-- THIS IMG SRC IS THE ONLY THING THAT HAS CHANGED -->
            <img src="msdeq_logo.jpeg" alt="Mississippi Department of Environmental Quality Logo" width="100">
        </a>
    </header>
    
    <main>
        <nav class="tab" role="tablist">
            <button class="tablinks" onclick="openTab(event, 'AirQualityData')" id="defaultOpen" role="tab" aria-selected="true" aria-controls="AirQualityData">Current Air Quality</button>
            <button class="tablinks" onclick="openTab(event, 'HistoricalData')" role="tab" aria-selected="false" aria-controls="HistoricalData">Historical Data</button>
            <button class="tablinks" onclick="openTab(event, 'Trends')" role="tab" aria-selected="false" aria-controls="Trends">Historical Trends</button>
            <button class="tablinks" onclick="openTab(event, 'Forecast')" role="tab" aria-selected="false" aria-controls="Forecast">Air Quality Forecast</button>
            <a href="https://www.airnow.gov/" target="_blank" rel="noopener noreferrer">AirNow.gov</a>
            <a href="https://fire.airnow.gov/" target="_blank" rel="noopener noreferrer">Fire & Smoke Map</a>
            <a href="https://www.airnow.gov/aqi/" target="_blank" rel="noopener noreferrer">AQI Info</a>
            <a href="https://www.mdeq.ms.gov/air/" target="_blank" rel="noopener noreferrer">MDEQ Air Homepage</a>
        </nav>
        
        <div class="aqi-legend">
            <h3>Air Quality Index (AQI) Legend</h3>
            <div class="aqi-legend-items">
                <div class="aqi-legend-item">
                    <div class="aqi-color" style="background-color: var(--good-color);"></div>
                    <span>Good (0-50)</span>
                </div>
                <div class="aqi-legend-item">
                    <div class="aqi-color" style="background-color: var(--moderate-color);"></div>
                    <span>Moderate (51-100)</span>
                </div>
                <div class="aqi-legend-item">
                    <div class="aqi-color" style="background-color: var(--unhealthy-sensitive-color);"></div>
                    <span>Unhealthy for Sensitive Groups (101-150)</span>
                </div>
                <div class="aqi-legend-item">
                    <div class="aqi-color" style="background-color: var(--unhealthy-color);"></div>
                    <span>Unhealthy (151-200)</span>
                </div>
                <div class="aqi-legend-item">
                    <div class="aqi-color" style="background-color: var(--very-unhealthy-color);"></div>
                    <span>Very Unhealthy (201-300)</span>
                </div>
                <div class="aqi-legend-item">
                    <div class="aqi-color" style="background-color: var(--hazardous-color);"></div>
                    <span>Hazardous (301+)</span>
                </div>
            </div>
        </div>
        
        <section id="AirQualityData" class="tabcontent" role="tabpanel" aria-labelledby="defaultOpen">
            <h2>Current Air Quality Data</h2>
            
            <div>
                <label for="parameter-select">Select Air Quality Parameter:</label>
                <select id="parameter-select" aria-label="Select air quality parameter">
                    <option value="">Loading parameters...</option>
                </select>
                <button id="share-map" class="share-button">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                        <path d="M13.5 1a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3zM11 2.5a2.5 2.5 0 1 1 .603 1.628l-6.718 3.12a2.499 2.499 0 0 1 0 1.504l6.718 3.12a2.5 2.5 0 1 1-.488.876l-6.718-3.12a2.5 2.5 0 1 1 0-3.256l6.718-3.12A2.5 2.5 0 0 1 11 2.5zm-8.5 4a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3zm11 5.5a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3z"/>
                    </svg>
                    Share Map
                </button>
                <button id="refresh-current-data" class="share-button">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                        <path d="M11.534 7h3.932a.25.25 0 0 1 .192.41l-1.966 2.36a.25.25 0 0 1-.384 0l-1.966-2.36a.25.25 0 0 1 .192-.41zm-11 2h3.932a.25.25 0 0 0 .192-.41L2.692 6.23a.25.25 0 0 0-.384 0L.342 8.59A.25.25 0 0 0 .534 9z"/>
                        <path fill-rule="evenodd" d="M8 3c-1.552 0-2.94.707-3.857 1.818a.5.5 0 1 1-.771-.636A6.002 6.002 0 0 1 13.917 7H12.9A5.002 5.002 0 0 0 8 3zM3.1 9a5.002 5.002 0 0 0 8.757 2.182.5.5 0 1 1 .771.636A6.002 6.002 0 0 1 2.083 9H3.1z"/>
                    </svg>
                    Refresh Data
                </button>
            </div>
            
            <div id="current-date-display" style="text-align: center; margin: 10px 0; font-weight: bold;"></div>
            
            <div id="map-loader" class="loader" aria-live="polite" aria-label="Loading map data"></div>
            <div id="map-error" class="error-message" aria-live="polite"></div>
            
            <div id="map" aria-label="Map showing air quality data"></div>
            
            <div class="text-data" aria-live="polite">
                <h3>Air Quality Data Table</h3>
                <div id="data-table-container">
                    <p>Select a parameter to view tabular data</p>
                </div>
            </div>
        </section>
        
        <section id="HistoricalData" class="tabcontent" role="tabpanel">
            <h2>Historical Air Quality Data</h2>
            
            <div class="date-selector">
                <label for="historical-date">Select Date:</label>
                <input type="date" id="historical-date" aria-label="Select date for historical air quality data">
                <button id="update-historical-data" class="share-button">Load Historical Data</button>
            </div>
            
            <div>
                <label for="historical-parameter-select">Select Air Quality Parameter:</label>
                <select id="historical-parameter-select" aria-label="Select historical air quality parameter">
                    <option value="">Select parameter after loading data</option>
                </select>
                <button id="share-historical" class="share-button">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                        <path d="M13.5 1a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3zM11 2.5a2.5 2.5 0 1 1 .603 1.628l-6.718 3.12a2.499 2.499 0 0 1 0 1.504l6.718 3.12a2.5 2.5 0 1 1-.488.876l-6.718-3.12a2.5 2.5 0 1 1 0-3.256l6.718-3.12A2.5 2.5 0 0 1 11 2.5zm-8.5 4a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3zm11 5.5a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3z"/>
                    </svg>
                    Share Data
                </button>
            </div>
            
            <div id="historical-loader" class="loader" aria-live="polite" aria-label="Loading historical data"></div>
            <div id="historical-error" class="error-message" aria-live="polite"></div>
            
            <div id="historical-map" aria-label="Map showing historical air quality data"></div>
            
            <div class="text-data" aria-live="polite">
                <h3>Historical Air Quality Data Table</h3>
                <div id="historical-table-container">
                    <p>Select a date and parameter to view historical data</p>
                </div>
            </div>
        </section>
        
        <section id="Trends" class="tabcontent" role="tabpanel">
            <h2>Air Quality Historical Trends</h2>
            <div id="trends-analysis-title" style="text-align: center; margin: 10px 0; font-size: 1.1rem; font-weight: bold;"></div>
            
            <div>
                <label for="area-select">Select Reporting Area:</label>
                <select id="area-select" aria-label="Select reporting area">
                    <option value="">--Select an area--</option>
                    <option value="Cleveland">Cleveland</option>
                    <option value="Hattiesburg">Hattiesburg</option>
                    <option value="Hernando">Hernando</option>
                    <option value="Jackson">Jackson</option>
                    <option value="Meridian">Meridian</option>
                    <option value="Mississippi Gulf Coast">Mississippi Gulf Coast</option>
                    <option value="Tupelo">Tupelo</option>
                </select>
                <button id="share-trends" class="share-button">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                        <path d="M13.5 1a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3zM11 2.5a2.5 2.5 0 1 1 .603 1.628l-6.718 3.12a2.499 2.499 0 0 1 0 1.504l6.718 3.12a2.5 2.5 0 1 1-.488.876l-6.718-3.12a2.5 2.5 0 1 1 0-3.256l6.718-3.12A2.5 2.5 0 0 1 11 2.5zm-8.5 4a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3zm11 5.5a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3z"/>
                    </svg>
                    Share Trends
                </button>
            </div>
            
            <!-- New date range selector and analysis options -->
            <div class="date-range-selector">
                <label for="trend-start-date">Start Date:</label>
                <input type="date" id="trend-start-date" min="2019-01-01">
                
                <label for="trend-end-date">End Date:</label>
                <input type="date" id="trend-end-date">
                
                <label for="trend-analysis-type">Analysis Type:</label>
                <select id="trend-analysis-type">
                    <option value="time-series">Time Series</option>
                    <option value="exceedance">Exceedance Days</option>
                    <option value="monthly-avg">Monthly Averages</option>
                    <option value="pollutant-comparison">Multi-Pollutant Comparison</option>
                    <option value="statistical">Statistical Summary</option>
                </select>
                
                <div id="multi-pollutant-options" style="display: none; margin-top: 10px;">
                    <label>Select Pollutants to Compare:</label><br>
                    <input type="checkbox" id="compare-ozone" value="OZONE" checked>
                    <label for="compare-ozone">Ozone</label>
                    
                    <input type="checkbox" id="compare-pm25" value="PM2.5">
                    <label for="compare-pm25">PM2.5</label>
                    
                    <input type="checkbox" id="compare-pm10" value="PM10">
                    <label for="compare-pm10">PM10</label>
                    
                    <input type="checkbox" id="compare-no2" value="NO2">
                    <label for="compare-no2">NO2</label>
                    
                    <input type="checkbox" id="compare-so2" value="SO2">
                    <label for="compare-so2">SO2</label>
                    
                    <input type="checkbox" id="compare-co" value="CO">
                    <label for="compare-co">CO</label>
                </div>
                
                <button id="update-trend-analysis" class="share-button">Analyze Data</button>
            </div>
            
            <div id="trends-loader" class="loader" aria-live="polite" aria-label="Loading trend data"></div>
            <div id="trends-error" class="error-message" aria-live="polite"></div>
            
            <!-- Container for exceedance analysis -->
            <div id="exceedance-summary" class="analysis-container" style="display: none; margin-top: 20px;">
                <h3>Exceedance Analysis</h3>
                <div id="exceedance-content"></div>
            </div>
            
            <!-- Container for statistical summary -->
            <div id="statistical-summary" class="analysis-container" style="display: none; margin-top: 20px;">
                <h3>Statistical Summary</h3>
                <div id="statistics-content"></div>
            </div>
            
            <div class="chart-container" role="img" aria-label="Air quality trends chart"></div>
        </section>
        
        <section id="Forecast" class="tabcontent" role="tabpanel">
            <h2>Air Quality Forecast</h2>
            
            <div>
                <label for="pollutant-select">Select Pollutant:</label>
                <select id="pollutant-select">
                    <option value="O3">Ozone</option>
                    <option value="PM2.5">PM2.5</option>
                </select>
                <button id="share-forecast" class="share-button">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                        <path d="M13.5 1a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3zM11 2.5a2.5 2.5 0 1 1 .603 1.628l-6.718 3.12a2.499 2.499 0 0 1 0 1.504l6.718 3.12a2.5 2.5 0 1 1-.488.876l-6.718-3.12a2.5 2.5 0 1 1 0-3.256l6.718-3.12A2.5 2.5 0 0 1 11 2.5zm-8.5 4a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3zm11 5.5a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3z"/>
                    </svg>
                    Share Forecast
                </button>
            </div>
            
                <div style="text-align: center; margin: 15px auto; padding: 10px; background-color: #e7f3fe; border-left: 5px solid var(--primary-color);">
                <p style="margin: 5px 0;">
                    <a href="https://www.enviroflash.info/signup.cfm" target="_blank" rel="noopener noreferrer" class="share-button" style="text-decoration: none; display: inline-flex;">Sign Up for Forecast Emails (EnviroFlash)</a>
                </p>
                <div id="ozone-season-note" style="display: none; font-size: 0.9em; margin-top: 10px;">
                    <strong>Note:</strong> The Mississippi ozone monitoring and forecasting season runs from March 1st to October 31st. The Jackson NCORE site monitors for ozone year-round.
                </div>
            </div>
            
            <div id="forecast-loader" class="loader" aria-live="polite" aria-label="Loading forecast data"></div>
            <div id="forecast-error" class="error-message" aria-live="polite"></div>
            
            <div id="forecast-container" class="forecast-container" aria-live="polite">
                <div id="forecast-hernando" class="forecast-item"></div>
                <div id="forecast-jackson" class="forecast-item"></div>
                <div id="forecast-gulf-coast" class="forecast-item"></div>
            </div>
        </section>
    </main>
    
    <footer>
        <div style="display: flex; flex-wrap: wrap; justify-content: space-around; margin-bottom: 15px;">
            <div style="margin: 0 10px;">
                <h4 style="margin-bottom: 10px;">AQI Resources</h4>
                <ul style="list-style: none; padding-left: 0;">
                    <li><a href="https://www.airnow.gov/" target="_blank" rel="noopener noreferrer">AirNow.gov</a></li>
                    <li><a href="https://fire.airnow.gov/" target="_blank" rel="noopener noreferrer">Fire & Smoke Map</a></li>
                    <li><a href="https://www.airnow.gov/aqi/" target="_blank" rel="noopener noreferrer">Air Quality Index Info</a></li>
                    <li><a href="https://www.airnow.gov/aqi/aqi-basics/" target="_blank" rel="noopener noreferrer">AQI Basics</a></li>
                </ul>
            </div>
        </div>
        <p>&copy; 2025 Mississippi Department of Environmental Quality. All rights reserved.</p>
        <p>Data provided by AirNow API and MDEQ monitoring stations.</p>
        <p>
    For air quality information inquiries, please contact Rodney Cuevas at 
    <a href="mailto:RCuevas@mdeq.ms.gov">RCuevas@mdeq.ms.gov</a> or 
    <a href="tel:+16019615566">(601) 961-5566</a>.
</p>
    </footer>
    
    <script src="https://unpkg.com/leaflet/dist/leaflet.js" crossorigin=""></script>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.4.0/dist/chartjs-plugin-annotation.min.js"></script>
    
    <script>
        // Initialize page when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize the maps
            initMap();
            initHistoricalMap();
            
            // Set max date for historical picker to today
            const historicalDateInput = document.getElementById('historical-date');
            const today = new Date();
            const maxDate = today.toISOString().split('T')[0];
            historicalDateInput.max = maxDate;
            
            // Set default date to yesterday for historical data
            const yesterday = new Date();
            yesterday.setDate(yesterday.getDate() - 1);
            historicalDateInput.valueAsDate = yesterday;
            
            // Fetch initial current data
            fetchHourlyData(today);

            // Set up auto-refresh every 5 minutes to check for new data
            setInterval(() => {
                console.log("Auto-refreshing current data...");
                fetchHourlyData(new Date());
                updateCurrentDateDisplay();
            }, 5 * 60 * 1000); // 5 minutes in milliseconds
            
            // Display current date
            updateCurrentDateDisplay();
            
            // Set up event listener for refresh button
            document.getElementById('refresh-current-data').addEventListener('click', () => {
                const today = new Date();
                fetchHourlyData(today);
                updateCurrentDateDisplay();
            });
            
            // Set up event listener for historical date selection
            document.getElementById('update-historical-data').addEventListener('click', () => {
                const dateInput = document.getElementById('historical-date');
                if (dateInput.value) {
                    // Parse the date explicitly to avoid timezone issues
                    const [year, month, day] = dateInput.value.split('-').map(Number);
                    
                    // Create date with noon time to avoid timezone shifts
                    const selectedDate = new Date(year, month - 1, day, 12, 0, 0, 0);
                    
                    console.log("Selected date input value:", dateInput.value);
                    console.log("Parsed date components:", year, month, day);
                    console.log("Selected historical date:", selectedDate);
                    
                    fetchHistoricalData(selectedDate);
                } else {
                    // If no date is selected, show error
                    const historicalError = document.getElementById('historical-error');
                    historicalError.textContent = 'Please select a date to view historical data.';
                    historicalError.style.display = 'block';
                }
            });
            
            // Initialize tabs
            document.getElementById('defaultOpen').click();
            
            // Set up event listeners for trend data
            document.getElementById('area-select').addEventListener('change', function() {
                const selectedArea = this.value;
                if (selectedArea) {
                    fetchTrendData(selectedArea);
                } else {
                    clearCharts();
                }
            });
            
            // Set up event listener for forecast data
            document.getElementById('pollutant-select').addEventListener('change', updateForecasts);
            
            // The event listener now calls our new reusable function
            document.getElementById('pollutant-select').addEventListener('change', checkOzoneNoteVisibility);
            
            // Set up share buttons
            document.getElementById('share-map').addEventListener('click', () => shareContent('map'));
            document.getElementById('share-historical').addEventListener('click', () => shareContent('historical'));
            document.getElementById('share-trends').addEventListener('click', () => shareContent('trends'));
            document.getElementById('share-forecast').addEventListener('click', () => shareContent('forecast'));
            
            // Initialize trend analysis options
            const trendStartDate = document.getElementById('trend-start-date');
            const trendEndDate = document.getElementById('trend-end-date');
            const analysisType = document.getElementById('trend-analysis-type');
            const multiPollutantOptions = document.getElementById('multi-pollutant-options');

            // Set default date range (last 30 days)
            const thirtyDaysAgo = new Date();
            thirtyDaysAgo.setDate(today.getDate() - 30);
            trendEndDate.valueAsDate = today;
            trendStartDate.valueAsDate = thirtyDaysAgo;

            // Set max date to today
            trendEndDate.max = today.toISOString().split('T')[0];
            trendStartDate.min = "2019-01-01";

            // Show/hide multi-pollutant options based on analysis type
            analysisType.addEventListener('change', function() {
                if (this.value === 'pollutant-comparison') {
                    multiPollutantOptions.style.display = 'block';
                } else {
                    multiPollutantOptions.style.display = 'none';
                }
            });

            // Setup event listener for the analyze button
            document.getElementById('update-trend-analysis').addEventListener('click', function() {
                const selectedArea = document.getElementById('area-select').value;
                if (!selectedArea) {
                    alert('Please select a reporting area first.');
                    return;
                }

                const trendStartDateInput = document.getElementById('trend-start-date');
                const trendEndDateInput = document.getElementById('trend-end-date');

                if (!trendStartDateInput.value || !trendEndDateInput.value) {
                     alert('Please select both a start and end date.');
                     return;
                }

                // ----> Manual Date Parsing (More Robust Fix) <----
                const startValue = trendStartDateInput.value; // e.g., "2025-03-01"
                const endValue = trendEndDateInput.value;   // e.g., "2025-03-30"

                // Split into components [Year, Month, Day]
                const [startYear, startMonth, startDay] = startValue.split('-').map(Number);
                const [endYear, endMonth, endDay] = endValue.split('-').map(Number);

                // Create Date objects using components. Month is 0-indexed (0=Jan, 1=Feb, etc.).
                // Set the time to noon (12:00:00) in the local timezone.
                // This avoids potential issues with DST changes or midnight timezone boundaries.
                const startDate = new Date(startYear, startMonth - 1, startDay, 12, 0, 0);
                const endDate = new Date(endYear, endMonth - 1, endDay, 12, 0, 0);
                // ----> End of Manual Parsing Fix <----

                // Check if dates were parsed correctly
                if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
                    alert('Invalid date selected. Please check your dates.');
                    return;
                }

                if (startDate > endDate) {
                    alert('Start date must be before end date.');
                    return;
                }

                // Add logs to verify the created dates
                console.log(`DEBUG: Parsed Start Date Object: ${startDate.toString()}`);
                console.log(`DEBUG: Parsed End Date Object: ${endDate.toString()}`);

                const analysisType = document.getElementById('trend-analysis-type').value;
                document.getElementById('trends-loader').style.display = 'block';
                document.getElementById('trends-error').style.display = 'none';

                // Pass these carefully constructed Date objects
                fetchHistoricalTrendData(selectedArea, startDate, endDate, analysisType);
            });
            
            // ----> ADD THIS BLOCK TO PRE-LOAD TRENDS <----
            // Set a default area and trigger the analysis for a better initial experience
            const defaultAreaSelect = document.getElementById('area-select');
            if (defaultAreaSelect) {
                defaultAreaSelect.value = 'Jackson'; // Set default to Jackson
                // Trigger the 'Analyze Data' button's click event to load the default view
                document.getElementById('update-trend-analysis').click();
            }
        });
        
        // Function to update current date display
        function updateCurrentDateDisplay() {
            const dateDisplay = document.getElementById('current-date-display');
            const now = new Date();
            dateDisplay.textContent = `Current data as of: ${now.toLocaleDateString('en-US', {
                weekday: 'long',
                year: 'numeric',
                month: 'long',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            })}`;
        }
        
        // Cache object for API responses
        const apiCache = {};
        
        // Define site locations
        const siteLocations = {
            'CLEVELAND': { lat: 33.7508, lng: -90.7342 },
            'GPORT YC': { lat: 30.3901, lng: -89.0497 },
            'Hattiesburg': { lat: 31.3240, lng: -89.2922 },
            'HERNANDO': { lat: 34.8206, lng: -89.9878 },
            'Hinds CC': { lat: 32.3467, lng: -90.2258 },
            'MERIDIAN': { lat: 32.3643, lng: -88.7314 },
            'Jackson NCORE': { lat: 32.3290, lng: -90.1827 },
            'PASCAGOULA': { lat: 30.3781, lng: -88.5339 },
            'TUPELOAP': { lat: 34.2648, lng: -88.7668 },
            'WAVELAND': { lat: 30.3009, lng: -89.3960 },
        };

        // Create layer groups for the markers
        let markers;
        let map;
        let historicalMarkers;
        let historicalMap;
        
        // Function to get AQI color based on pollutant value
    function getAQIColor(parameter, value) {
        if (parameter === 'PM2.5') {
            if (value <= 9.0) return 'var(--good-color)';
            else if (value <= 35.4) return 'var(--moderate-color)';
            else if (value <= 55.4) return 'var(--unhealthy-sensitive-color)';
            else if (value <= 150.4) return 'var(--unhealthy-color)';
            else if (value <= 250.4) return 'var(--very-unhealthy-color)';
            else return 'var(--hazardous-color)';
        } else if (parameter === 'OZONE') {
            if (value <= 54) return 'var(--good-color)';
            else if (value <= 70) return 'var(--moderate-color)';
            else if (value <= 85) return 'var(--unhealthy-sensitive-color)';
            else if (value <= 105) return 'var(--unhealthy-color)';
            else if (value <= 200) return 'var(--very-unhealthy-color)';
            else return 'var(--hazardous-color)';
        } else if (parameter === 'SO2') {
            if (value <= 35) return 'var(--good-color)';
            else if (value <= 75) return 'var(--moderate-color)';
            else if (value <= 185) return 'var(--unhealthy-sensitive-color)';
            else if (value <= 304) return 'var(--unhealthy-color)';
            else return 'var(--very-unhealthy-color)';
        } else if (parameter === 'NO2') {
            if (value <= 53) return 'var(--good-color)';
            else if (value <= 100) return 'var(--moderate-color)';
            else if (value <= 360) return 'var(--unhealthy-sensitive-color)';
            else if (value <= 649) return 'var(--unhealthy-color)';
            else if (value <= 1249) return 'var(--very-unhealthy-color)';
            else return 'var(--hazardous-color)';
        } else if (parameter === 'CO') {
            if (value <= 4.4) return 'var(--good-color)';
            else if (value <= 9.4) return 'var(--moderate-color)';
            else if (value <= 12.4) return 'var(--unhealthy-sensitive-color)';
            else if (value <= 15.4) return 'var(--unhealthy-color)';
            else if (value <= 30.4) return 'var(--very-unhealthy-color)';
            else return 'var(--hazardous-color)';
        } else if (parameter === 'PM10') {
            if (value <= 50) return 'var(--good-color)';
            else if (value <= 100) return 'var(--moderate-color)';
            else if (value <= 150) return 'var(--unhealthy-sensitive-color)';
            else if (value <= 200) return 'var(--unhealthy-color)';
            else if (value <= 300) return 'var(--very-unhealthy-color)';
            else return 'var(--hazardous-color)';
        }
        return 'gray'; // Default color
    }

    // Get AQI category name
    function getAQICategory(value, parameter) {
        if (parameter === 'PM2.5') {
            if (value <= 9.0) return 'Good';
            else if (value <= 35.4) return 'Moderate';
            else if (value <= 55.4) return 'Unhealthy for Sensitive Groups';
            else if (value <= 150.4) return 'Unhealthy';
            else if (value <= 250.4) return 'Very Unhealthy';
            else return 'Hazardous';
        } else {
            // Default thresholds for other parameters
            if (value <= 50) return 'Good';
            else if (value <= 100) return 'Moderate';
            else if (value <= 150) return 'Unhealthy for Sensitive Groups';
            else if (value <= 200) return 'Unhealthy';
            else if (value <= 300) return 'Very Unhealthy';
            else return 'Hazardous';
        }
    }
        
        // Function to format date for API requests
        function formatDate(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}${month}${day}`;
        }
        
        // Function to initialize map
        function initMap() {
            map = L.map('map').setView([32.3547, -89.3985], 7);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 19,
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);
            
            markers = L.layerGroup().addTo(map);
        }

        // Function to initialize historical map
        function initHistoricalMap() {
            historicalMap = L.map('historical-map').setView([32.3547, -89.3985], 7);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 19,
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(historicalMap);
            
            historicalMarkers = L.layerGroup().addTo(historicalMap);
        }
        
                // New helper function to get AQI category from an AQI value
        function getCategoryFromAqi(aqi) {
            if (aqi <= 50) return 'Good';
            if (aqi <= 100) return 'Moderate';
            if (aqi <= 150) return 'Unhealthy for Sensitive Groups';
            if (aqi <= 200) return 'Unhealthy';
            if (aqi <= 300) return 'Very Unhealthy';
            if (aqi > 300) return 'Hazardous';
            return 'Unknown';
        }

        // New helper function to get colors from an AQI value
        function getColorsFromAqi(aqi) {
            if (aqi <= 50) return { bgColor: '#00e400', textColor: 'black' };
            if (aqi <= 100) return { bgColor: '#ffff00', textColor: 'black' };
            if (aqi <= 150) return { bgColor: '#ff7e00', textColor: 'white' };
            if (aqi <= 200) return { bgColor: '#ff0000', textColor: 'white' };
            if (aqi <= 300) return { bgColor: '#99004c', textColor: 'white' };
            if (aqi > 300) return { bgColor: '#7e0023', textColor: 'white' };
            return { bgColor: 'gray', textColor: 'white' };
        }
        
                // Helper object to store AQI category descriptions and health effects
        const aqiCategoryInfo = {
            'Good': {
                description: 'Air quality is satisfactory, and air pollution poses little or no risk.'
            },
            'Moderate': {
                description: 'Air quality is acceptable. However, there may be a risk for some people, particularly those who are unusually sensitive to air pollution.'
            },
            'Unhealthy for Sensitive Groups': {
                description: 'Members of sensitive groups may experience health effects. The general public is less likely to be affected.'
            },
            'Unhealthy': {
                description: 'Some members of the general public may experience health effects; members of sensitive groups may experience more serious health effects.'
            },
            'Very Unhealthy': {
                description: 'Health alert: The risk of health effects is increased for everyone.'
            },
            'Hazardous': {
                description: 'Health warning of emergency conditions: everyone is more likely to be affected.'
            }
        };
        
                // Reusable function to create a custom AQI marker
        function createAqiMarker(location, data, selectedParameter) {
            const value = parseFloat(data.value);
            const quality = getAQICategory(value, selectedParameter);
            
            let markerColor;
            if (quality === 'Good') markerColor = '#00e400';
            else if (quality === 'Moderate') markerColor = '#ffff00';
            else if (quality === 'Unhealthy for Sensitive Groups') markerColor = '#ff7e00';
            else if (quality === 'Unhealthy') markerColor = '#ff0000';
            else if (quality === 'Very Unhealthy') markerColor = '#99004c';
            else markerColor = '#7e0023';

            const textColor = (quality === 'Good' || quality === 'Moderate') ? 'black' : 'white';
            
            const iconHtml = `<div style="
                background-color: ${markerColor}; 
                border-radius: 50%; 
                width: 30px; 
                height: 30px; 
                display: flex; 
                justify-content: center; 
                align-items: center; 
                color: ${textColor}; 
                font-weight: bold; 
                border: 2px solid white;
                box-shadow: 0 1px 3px rgba(0,0,0,0.3);
                font-size: 10px;
            ">${data.value}</div>`;
            
            return L.marker([location.lat, location.lng], {
                icon: L.divIcon({
                    html: iconHtml,
                    className: 'custom-div-icon',
                    iconSize: [30, 30],
                    iconAnchor: [15, 15]
                })
            });
        }
        
        // Function to get the URL for hourly data
        function getHourlyDataUrl(date) {
            // If no date is provided, use current date
            const now = new Date();
            let selectedDate = date ? new Date(date) : new Date();
            
            // Get current UTC date and time
            const nowUTC = new Date(Date.UTC(
                now.getUTCFullYear(),
                now.getUTCMonth(),
                now.getUTCDate(),
                now.getUTCHours(),
                now.getUTCMinutes()
            ));
            
            // Check if we're at the UTC day boundary (7PM CDT / 00Z UTC)
            const isAtDayBoundary = now.getUTCHours() === 0 && 
                                selectedDate.toDateString() === now.toDateString();
            
            // Determine target hour based on current time
            let targetHour;
            let targetDate = new Date(selectedDate);
            
            if (isAtDayBoundary) {
                // At 7PM CDT (00Z of next day), we want previous day's hour 23
                targetHour = 23;
                targetDate.setDate(targetDate.getDate() - 1); // Use previous day
                console.log("Day boundary detected (7PM CDT / 00Z UTC) - Using previous day with hour 23");
            } else if (selectedDate.toDateString() === now.toDateString()) {
                // For today (not at boundary), use most recent hour
                // If we're in the first 15 minutes of a new hour, use the hour before the previous hour
                // This adds a buffer for data availability
                const minutes = now.getMinutes();
                if (minutes < 10) {
                    targetHour = Math.max(now.getUTCHours() - 2, 0);
                    console.log(`First 10 minutes of hour detected (${minutes} min) - Using hour from 2 hours ago`);
                    if (targetHour === 0 && now.getUTCHours() <= 1) {
                        // If it's the first or second hour of the day UTC and we need to go back 2 hours, use previous day
                        targetHour = now.getUTCHours() === 0 ? 22 : 23;
                        targetDate.setDate(targetDate.getDate() - 1);
                        console.log(`Early hours - Using previous day with hour ${targetHour}`);
                    }
                } else {
                    // Otherwise use the previous hour as before
                    targetHour = Math.max(now.getUTCHours() - 1, 0);
                    if (targetHour === 0 && now.getUTCHours() === 0) {
                        // If it's just after midnight UTC, use previous day's hour 23
                        targetHour = 23;
                        targetDate.setDate(targetDate.getDate() - 1);
                    }
                }
            } else {
                // For past dates, use the end of day
                targetHour = 23;
            }
            
            // Format the date components for the URL
            let year = targetDate.getUTCFullYear();
            let month = String(targetDate.getUTCMonth() + 1).padStart(2, '0');
            let day = String(targetDate.getUTCDate()).padStart(2, '0');
            let hour = String(targetHour).padStart(2, '0');
            
            console.log(`Fetching data for: ${year}-${month}-${day} ${hour}:00 UTC`);
            console.log(`Local time: ${now.toLocaleString()}, UTC time: ${nowUTC.toISOString()}`);
            
            return `https://s3-us-west-1.amazonaws.com//files.airnowtech.org/airnow/today/HourlyData_${year}${month}${day}${hour}.dat`;
        }
        
        // Function to fetch and display hourly data
        async function fetchHourlyData(date) {  
            const mapLoader = document.getElementById('map-loader');
            const mapError = document.getElementById('map-error');
            
            // Show loader
            mapLoader.style.display = 'block';
            mapError.style.display = 'none';
            
            // Store current displayed data before attempting fetch
            const currentDisplayedData = apiCache.currentDisplayedData || null;
            
            // Try the initial URL
            const initialUrl = getHourlyDataUrl(date);
            
            try {
                // Check cache first for ALL known data, not just the initial URL
                const cachedUrls = Object.keys(apiCache).filter(url => 
                    url.includes('HourlyData_') && 
                    url.endsWith('.dat')
                );
                
                // If we have cached data, use the most recent one first
                if (cachedUrls.length > 0) {
                    // Sort by date in URL to get the most recent
                    cachedUrls.sort((a, b) => {
                        // Extract the date and hour from the URL
                        const dateA = a.match(/HourlyData_(\d{8})(\d{2})\.dat/);
                        const dateB = b.match(/HourlyData_(\d{8})(\d{2})\.dat/);
                        
                        if (dateA && dateB) {
                            const fullDateA = dateA[1] + dateA[2];
                            const fullDateB = dateB[1] + dateB[2];
                            return fullDateB.localeCompare(fullDateA); // Descending order
                        }
                        return 0;
                    });
                    
                    console.log(`Found ${cachedUrls.length} cached data sets. Using the most recent: ${cachedUrls[0]}`);
                    
                    // Always try to fetch new data, but display cached data immediately
                    displayHourlyData(apiCache[cachedUrls[0]]);
                    mapLoader.style.display = 'none';
                    
                    // Save this as current displayed data
                    apiCache.currentDisplayedData = apiCache[cachedUrls[0]];
                }
                
                // Always try to fetch the latest data, even if we're showing cached data
                console.log(`Attempting to fetch latest data: ${initialUrl}`);
                const response = await fetch(initialUrl);
                
                if (response.ok) {
                    const data = await response.text();
                    apiCache[initialUrl] = data;
                    displayHourlyData(data);
                    apiCache.currentDisplayedData = data;
                    console.log("Successfully updated with latest data");
                    return;
                } else {
                    console.log(`Latest data not available yet (status: ${response.status}), trying fallbacks...`);
                    
                    // If we don't have new data but have previously displayed data, keep using it
                    if (apiCache.currentDisplayedData) {
                        console.log("Using previously displayed data until new data is available");
                        // No need to redisplay as we already displayed it above
                        mapLoader.style.display = 'none';
                        return;
                    }
                }
                
                // If initial request failed, try with the current hour minus 2
                const selectedDate = date ? new Date(date) : new Date();
                const fallbackDate = new Date(selectedDate);
                
                // Set fallback hours to try
                let fallbackHours = [];
                
                // If today, try current hour minus 2 and minus 3
                if (selectedDate.toDateString() === new Date().toDateString()) {
                    const currentHour = new Date().getUTCHours();
                    fallbackHours = [
                        Math.max(currentHour - 2, 0),
                        Math.max(currentHour - 3, 0),
                        Math.max(currentHour - 4, 0)  // Added an extra fallback hour
                    ];
                } else {
                    // If not today, try hours 22, 21, 20
                    fallbackHours = [22, 21, 20];
                }
                
                // If we've already displayed cached data, don't show loader anymore
                if (cachedUrls.length === 0) {
                    mapLoader.style.display = 'block';
                }
                
                // Try each fallback hour
                for (const hour of fallbackHours) {
                    fallbackDate.setUTCHours(hour);
                    const fallbackUrl = getHourlyDataUrl(fallbackDate);
                    
                    console.log(`Trying fallback hour: ${hour}:00 UTC`);
                    
                    // Skip if it's the same as the initial URL
                    if (fallbackUrl === initialUrl) continue;
                    
                    // Check cache for fallback
                    if (apiCache[fallbackUrl]) {
                        displayHourlyData(apiCache[fallbackUrl]);
                        apiCache.currentDisplayedData = apiCache[fallbackUrl];
                        mapLoader.style.display = 'none';
                        return;
                    }
                    
                    // Try to fetch with fallback
                    try {
                        const fallbackResponse = await fetch(fallbackUrl);
                        if (fallbackResponse.ok) {
                            const data = await fallbackResponse.text();
                            apiCache[fallbackUrl] = data;
                            displayHourlyData(data);
                            apiCache.currentDisplayedData = data;
                            return;
                        }
                    } catch (error) {
                        console.error(`Error with fallback hour ${hour}:`, error);
                    }
                }
                
                // If we've gotten this far and haven't displayed any data yet (no cache, all fetches failed)
                // Only then show the error
                if (!Object.keys(apiCache).some(key => key.includes('HourlyData_'))) {
                    throw new Error('Data not available for the selected date and time');
                } else {
                    console.log("Using previously cached data as fallback");
                    // We already displayed the cached data earlier, so just hide the loader
                    mapLoader.style.display = 'none';
                }
                
            } catch (error) {
                console.error('Error fetching hourly data:', error);
                
                // Check if we have ANY cached data we can use
                const cachedUrls = Object.keys(apiCache).filter(url => 
                    url.includes('HourlyData_') && 
                    url.endsWith('.dat')
                );
                
                if (cachedUrls.length > 0) {
                    // Sort to get the most recent
                    cachedUrls.sort((a, b) => {
                        const dateA = a.match(/HourlyData_(\d{8})(\d{2})\.dat/);
                        const dateB = b.match(/HourlyData_(\d{8})(\d{2})\.dat/);
                        
                        if (dateA && dateB) {
                            const fullDateA = dateA[1] + dateA[2];
                            const fullDateB = dateB[1] + dateB[2];
                            return fullDateB.localeCompare(fullDateA);
                        }
                        return 0;
                    });
                    
                    console.log(`Error occurred, but using cached data: ${cachedUrls[0]}`);
                    displayHourlyData(apiCache[cachedUrls[0]]);
                    apiCache.currentDisplayedData = apiCache[cachedUrls[0]];
                } else if (apiCache.currentDisplayedData) {
                    // If no cached data but we have previously displayed data, use that
                    console.log("Error occurred, but using previously displayed data");
                    displayHourlyData(apiCache.currentDisplayedData);
                } else {
                    // Only show error if we have no cached data to display
                    mapError.textContent = 'Failed to load air quality data. Please try again later. Error: ' + error.message;
                    mapError.style.display = 'block';
                }
            } finally {
                mapLoader.style.display = 'none';
            }
        }
        
        // Function to parse and display hourly data
        function displayHourlyData(data) {
            const rows = data.split('\n');
            const parsedData = rows.map(row => {
                const [validDate, validTime, aqsid, siteName, gmtOffset, parameterName, reportingUnits, value, dataSource] = row.split('|');
                return {validDate, validTime, aqsid, siteName, gmtOffset, parameterName, reportingUnits, value, dataSource};
            }).filter(d => d.validDate); // Filter out empty rows

            const includedParameters = ['OZONE', 'PM10', 'PM2.5', 'SO2', 'NO2', 'CO'];
            const filteredData = parsedData.filter(d => includedParameters.includes(d.parameterName));
            
            // Populate parameter select dropdown
            const parameters = [...new Set(filteredData.map(d => d.parameterName))];
            const select = document.getElementById('parameter-select');
            select.innerHTML = '';
            
            parameters.forEach(param => {
                const option = document.createElement('option');
                option.value = param;
                option.textContent = param;
                select.appendChild(option);
            });
            
            // Set default parameter if available
            if (parameters.includes('OZONE')) {
                select.value = 'OZONE';
            } else if (parameters.length > 0) {
                select.value = parameters[0];
            }
            
            // Update map markers and data table
            updateMapAndTable(filteredData, select.value);
            
            // Add change event listener to parameter select
            select.addEventListener('change', () => {
                updateMapAndTable(filteredData, select.value);
            });
        }
        
                // Function to update map and data table to show calculated AQI values
        function updateMapAndTable(data, selectedParameter) {
            const filteredData = data.filter(d => d.parameterName === selectedParameter);
            markers.clearLayers();
            
            const mississippiSites = Object.keys(siteLocations);
            const mississippiData = filteredData.filter(d => mississippiSites.includes(d.siteName));
            
            mississippiData.forEach(d => {
                const location = siteLocations[d.siteName];
                if (location) {
                    const concentration = parseFloat(d.value);
                    if (isNaN(concentration)) return; // Skip if value is not a number

                    // Calculate AQI from the concentration value
                    const aqiValue = convertToAQI(concentration, selectedParameter);
                    const quality = getCategoryFromAqi(aqiValue);
                    const { bgColor: markerColor, textColor } = getColorsFromAqi(aqiValue);
                    
                    // Create an HTML element for the marker to display the AQI
                    const iconHtml = `<div style="
                        background-color: ${markerColor}; 
                        border-radius: 50%; 
                        width: 35px; 
                        height: 35px; 
                        display: flex; 
                        flex-direction: column;
                        justify-content: center; 
                        align-items: center; 
                        color: ${textColor}; 
                        font-weight: bold; 
                        border: 2px solid white;
                        box-shadow: 0 1px 3px rgba(0,0,0,0.3);
                        font-size: 9px;
                        line-height: 1;
                        padding-top: 2px;
                    ">AQI<div style="font-size: 14px; margin-top: -2px;">${aqiValue}</div></div>`;
                    
                    const customIcon = L.divIcon({
                        html: iconHtml,
                        className: 'custom-div-icon',
                        iconSize: [35, 35],
                        iconAnchor: [17, 17]
                    });
                    
                    const marker = L.marker([location.lat, location.lng], { 
                        icon: customIcon 
                    }).addTo(markers);
                    
                    // Update popup to show both AQI and concentration
                    const popupContent = `
                        <div style="min-width: 300px;">
                            <h3>${d.siteName}</h3>
                            <p><strong>Quality:</strong> ${quality}</p>
                            <p><strong>Calculated AQI:</strong> ${aqiValue}</p>
                            <p><strong>Concentration:</strong> ${d.value} ${d.reportingUnits}</p>
                            <p><strong>Time:</strong> ${convertZuluToCentralTime(d.validTime, d.validDate)} CT</p>
                            <div style="margin-top: 10px;">
                                <h4>Last 12 Hours Trend</h4>
                                <canvas id="trendChart-${d.siteName.replace(/\s+/g, '')}" width="280" height="200"></canvas>
                                <div id="chartLoader-${d.siteName.replace(/\s+/g, '')}" style="text-align: center; padding: 20px;">Loading historical data...</div>
                            </div>
                        </div>
                    `;
                    
                    const popup = L.popup({
                        maxWidth: 350,
                        maxHeight: 400,
                        autoPanPadding: [10, 10],
                        className: 'custom-popup'
                    }).setContent(popupContent);
                    
                    marker.bindPopup(popup);
                    
                    marker.on('popupopen', function() {
                        fetchHistoricalHourlyData(d.siteName, selectedParameter);
                    });
                }
            });
            
            updateDataTable(mississippiData, selectedParameter);
        }

        // Function to fetch historical hourly data for the past 12 hours
        async function fetchHistoricalHourlyData(siteName, parameter) {
            const chartId = `trendChart-${siteName.replace(/\s+/g, '')}`;
            const loaderId = `chartLoader-${siteName.replace(/\s+/g, '')}`;
            
            // Check if the chart element exists
            const chartElement = document.getElementById(chartId);
            const loaderElement = document.getElementById(loaderId);
            
            if (!chartElement || !loaderElement) return;
            
            try {
                // Calculate the start and end time (current hour - 12 hours)
                const now = new Date();
                const endHour = now.getUTCHours();
                
                // Array to store the hourly data
                const hourlyData = [];
                const labels = [];
                
                // Fetch data for the last 12 hours
                for (let i = 0; i < 12; i++) {
                    // Calculate target hour (going backward from current hour)
                    const targetDate = new Date(now);
                    targetDate.setUTCHours(now.getUTCHours() - i);
                    
                    const year = targetDate.getUTCFullYear();
                    const month = String(targetDate.getUTCMonth() + 1).padStart(2, '0');
                    const day = String(targetDate.getUTCDate()).padStart(2, '0');
                    const hour = String(targetDate.getUTCHours()).padStart(2, '0');
                    
                    const url = `https://s3-us-west-1.amazonaws.com//files.airnowtech.org/airnow/${year}/${year}${month}${day}/HourlyData_${year}${month}${day}${hour}.dat`;
                    
                    try {
                        // Check if data is already in cache
                        const cacheKey = `hourly_${year}${month}${day}${hour}`;
                        let response;
                        
                        if (apiCache[cacheKey]) {
                            response = apiCache[cacheKey];
                        } else {
                            const fetchResponse = await fetch(url);
                            if (fetchResponse.ok) {
                                response = await fetchResponse.text();
                                apiCache[cacheKey] = response;
                            } else {
                                console.log(`No data for hour ${hour} on ${year}-${month}-${day}`);
                                continue;
                            }
                        }
                        
                        // Parse the data for this site and parameter
                        const rows = response.split('\n');
                        for (const row of rows) {
                            const fields = row.split('|');
                            if (fields.length >= 9) {
                                const rowSiteName = fields[3];
                                const rowParameter = fields[5];
                                
                                if (rowSiteName === siteName && rowParameter === parameter) {
                                    const value = parseFloat(fields[7]);
                                    const date = fields[0];
                                    const time = fields[1];
                                    
                                    // Format time for display (convert to CT)
                                    const localTime = convertZuluToCentralTime(time, date);
                                    
                                    hourlyData.push(value);
                                    labels.push(localTime);
                                    break; // Found the data for this hour, move to next hour
                                }
                            }
                        }
                    } catch (error) {
                        console.error(`Error fetching hourly data for ${year}-${month}-${day} hour ${hour}:`, error);
                    }
                }
                
                // Reverse arrays to display oldest to newest
                hourlyData.reverse();
                labels.reverse();
                
                // Create the chart now that we have the data
                createHourlyTrendChart(chartId, labels, hourlyData, parameter);
                
                // Hide the loader
                loaderElement.style.display = 'none';
                
            } catch (error) {
                console.error('Error fetching historical hourly data:', error);
                loaderElement.textContent = 'Error loading historical data.';
            }
        }

        // Function to create the hourly trend chart
        function createHourlyTrendChart(chartId, labels, data, parameter) {
            const ctx = document.getElementById(chartId).getContext('2d');
            
            // Define color thresholds based on parameter
            let thresholds;
            
            switch(parameter) {
                case 'OZONE':
                    thresholds = [
                        { value: 0, color: '#00e400' },    // Good
                        { value: 55, color: '#ffff00' },   // Moderate
                        { value: 71, color: '#ff7e00' },   // Unhealthy for Sensitive Groups
                        { value: 86, color: '#ff0000' },   // Unhealthy
                        { value: 106, color: '#99004c' },  // Very Unhealthy
                        { value: 201, color: '#7e0023' }   // Hazardous
                    ];
                    break;
                case 'PM2.5':
                    thresholds = [
                        { value: 0, color: '#00e400' },    // Good
                        { value: 9.1, color: '#ffff00' },  // Moderate
                        { value: 35.5, color: '#ff7e00' }, // Unhealthy for Sensitive Groups
                        { value: 55.5, color: '#ff0000' }, // Unhealthy
                        { value: 150.5, color: '#99004c' },// Very Unhealthy
                        { value: 250.5, color: '#7e0023' } // Hazardous
                    ];
                    break;
                case 'PM10':
                    thresholds = [
                        { value: 0, color: '#00e400' },    // Good
                        { value: 55, color: '#ffff00' },   // Moderate
                        { value: 155, color: '#ff7e00' },  // Unhealthy for Sensitive Groups
                        { value: 255, color: '#ff0000' },  // Unhealthy
                        { value: 355, color: '#99004c' },  // Very Unhealthy
                        { value: 425, color: '#7e0023' }   // Hazardous
                    ];
                    break;
                default:
                    // Default thresholds
                    thresholds = [
                        { value: 0, color: '#00e400' },    // Good
                        { value: 51, color: '#ffff00' },   // Moderate
                        { value: 101, color: '#ff7e00' },  // Unhealthy for Sensitive Groups
                        { value: 151, color: '#ff0000' },  // Unhealthy
                        { value: 201, color: '#99004c' },  // Very Unhealthy
                        { value: 301, color: '#7e0023' }   // Hazardous
                    ];
            }
            
            // Generate point colors based on thresholds
            const pointColors = data.map(value => {
                for (let i = thresholds.length - 1; i >= 0; i--) {
                    if (value >= thresholds[i].value) {
                        return thresholds[i].color;
                    }
                }
                return thresholds[0].color; // Default color
            });
            
            // Create the chart
            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: `${parameter} Trend`,
                        data: data,
                        borderColor: '#0071bc',
                        backgroundColor: 'rgba(0, 113, 188, 0.1)',
                        borderWidth: 2,
                        pointBackgroundColor: pointColors,
                        pointBorderColor: pointColors,
                        pointRadius: 6,
                        pointHoverRadius: 8,
                        fill: false,
                        tension: 0.3
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: parameter === 'OZONE' ? 'ppb' : 
                                    parameter === 'PM2.5' || parameter === 'PM10' ? 'g/m' : 
                                    parameter === 'CO' ? 'ppm' : 'Value'
                            }
                        },
                        x: {
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                afterLabel: function(context) {
                                    const value = context.raw;
                                    return `Quality: ${getAQICategory(value, parameter)}`;
                                }
                            }
                        },
                        legend: {
                            display: false
                        }
                    }
                }
            });
            
            // Add AQI color legend below chart
            const chartCanvas = document.getElementById(chartId);
            const legendDiv = document.createElement('div');
            legendDiv.style.display = 'flex';
            legendDiv.style.flexWrap = 'wrap';
            legendDiv.style.justifyContent = 'center';
            legendDiv.style.fontSize = '9px';
            legendDiv.style.marginTop = '5px';
            
            // Add legend items
            const categories = [
                { name: 'Good', color: '#00e400' },
                { name: 'Moderate', color: '#ffff00' },
                { name: 'USG', color: '#ff7e00' },
                { name: 'Unhealthy', color: '#ff0000' },
                { name: 'V. Unhealthy', color: '#99004c' },
                { name: 'Hazardous', color: '#7e0023' }
            ];
            
            categories.forEach(category => {
                const item = document.createElement('div');
                item.style.display = 'flex';
                item.style.alignItems = 'center';
                item.style.margin = '2px 3px';
                
                const colorBox = document.createElement('span');
                colorBox.style.width = '10px';
                colorBox.style.height = '10px';
                colorBox.style.backgroundColor = category.color;
                colorBox.style.display = 'inline-block';
                colorBox.style.marginRight = '2px';
                
                const name = document.createElement('span');
                name.textContent = category.name;
                
                item.appendChild(colorBox);
                item.appendChild(name);
                legendDiv.appendChild(item);
            });
            
            // Insert legend after the chart
            chartCanvas.parentNode.insertBefore(legendDiv, chartCanvas.nextSibling);
        }
        
                // Function to create data table with both AQI and Concentration
        function updateDataTable(data, parameter) {
            const tableContainer = document.getElementById('data-table-container');
            
            if (data.length === 0) {
                tableContainer.innerHTML = `<p>No data available for ${parameter}</p>`;
                return;
            }
            
            data.sort((a, b) => a.siteName.localeCompare(b.siteName));
            
            // Updated table header
            let tableHTML = `
                <table class="data-table" style="width: 100%; border-collapse: collapse; margin-top: 20px;">
                    <thead>
                        <tr>
                            <th style="padding: 8px; border: 1px solid #ddd; background-color: #f2f2f2;">Site Name</th>
                            <th style="padding: 8px; border: 1px solid #ddd; background-color: #f2f2f2;">AQI</th>
                            <th style="padding: 8px; border: 1px solid #ddd; background-color: #f2f2f2;">Concentration</th>
                            <th style="padding: 8px; border: 1px solid #ddd; background-color: #f2f2f2;">Units</th>
                            <th style="padding: 8px; border: 1px solid #ddd; background-color: #f2f2f2;">Time (CT)</th>
                            <th style="padding: 8px; border: 1px solid #ddd; background-color: #f2f2f2;">Quality</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            data.forEach(d => {
                const concentration = parseFloat(d.value);
                if (isNaN(concentration)) return; // Skip if value is not a number
                
                // Calculate AQI and get corresponding category and colors
                const aqiValue = convertToAQI(concentration, parameter);
                const quality = getCategoryFromAqi(aqiValue);
                const { bgColor: backgroundColor, textColor } = getColorsFromAqi(aqiValue);
                
                const centralTime = convertZuluToCentralTime(d.validTime, d.validDate);
                
                // Updated table row structure
                tableHTML += `
                    <tr>
                        <td style="padding: 8px; border: 1px solid #ddd;">${d.siteName}</td>
                        <td style="padding: 8px; border: 1px solid #ddd; text-align: center; font-weight: bold;">${aqiValue}</td>
                        <td style="padding: 8px; border: 1px solid #ddd; text-align: right;">${d.value}</td>
                        <td style="padding: 8px; border: 1px solid #ddd;">${d.reportingUnits}</td>
                        <td style="padding: 8px; border: 1px solid #ddd;">${centralTime}</td>
                        <td style="padding: 8px; border: 1px solid #ddd; background-color: ${backgroundColor}; color: ${textColor};">${quality}</td>
                    </tr>
                `;
            });
            
            tableHTML += `
                    </tbody>
                </table>
                <p style="margin-top: 10px; font-style: italic;">Data last updated: ${new Date().toLocaleString()}</p>
            `;
            
            tableContainer.innerHTML = tableHTML;
        }

        // Function to convert Zulu time to Central Time
        function convertZuluToCentralTime(zuluTime, dateStr, showEndTime = true) {
    // Parse the time
    const [hours, minutes] = zuluTime.split(':').map(num => parseInt(num, 10));
    
    // Parse the date
    const [month, day, yearShort] = dateStr.split('/').map(num => parseInt(num, 10));
    const year = 2000 + yearShort;
    
    // Create a date object representing this time in UTC
    const utcDate = new Date(Date.UTC(year, month - 1, day, hours, minutes));
    
    // Apply the offset for CDT
    const centralOffset = -5;
    
    // If showing end time, add 1 hour to show when the measurement period ends
    const adjustedHours = showEndTime ? hours + 1 : hours;
    
    // Calculate central time hours
    const centralHoursUTC = adjustedHours + centralOffset;
    let centralHours = centralHoursUTC;
    if (centralHours < 0) {
        centralHours += 24;
    }
    
    // Format with AM/PM
    const ampm = centralHours >= 12 ? 'PM' : 'AM';
    centralHours = centralHours % 12;
    centralHours = centralHours ? centralHours : 12;
    
    // Format minutes
    const centralMinutes = String(minutes).padStart(2, '0');
    
    return `${centralHours}:${centralMinutes} ${ampm}`;
}
        
        // Function to fetch historical data
        function fetchHistoricalData(date) {
            const historicalLoader = document.getElementById('historical-loader');
            const historicalError = document.getElementById('historical-error');
            
            // Show loader
            historicalLoader.style.display = 'block';
            historicalError.style.display = 'none';
            
            // Create a new date object to avoid modifying the original
            // IMPORTANT: Clone the date but set hours to noon to avoid timezone issues
            const adjustedDate = new Date(date);
            adjustedDate.setHours(12, 0, 0, 0); // Set to noon to avoid any timezone shifting
            
            // Add a day to compensate for the timezone issue
            // This ensures when user selects the 8th, we request data for the 8th
            // adjustedDate.setDate(adjustedDate.getDate() + 1);
            
            // Log the original and adjusted dates for debugging
            console.log(`[DEBUG] Original selected date:`, date);
            console.log(`[DEBUG] Adjusted date (noon local time):`, adjustedDate);
            console.log(`[DEBUG] Date string:`, adjustedDate.toString());
            console.log(`[DEBUG] ISO string:`, adjustedDate.toISOString());
            
            // Format date for URL: YYYYMMDD
            const year = adjustedDate.getFullYear();
            const month = String(adjustedDate.getMonth() + 1).padStart(2, '0');
            const day = String(adjustedDate.getDate()).padStart(2, '0');
            const formattedDate = `${year}${month}${day}`;
            
            // Construct URL for historical data
            const url = `https://s3-us-west-1.amazonaws.com//files.airnowtech.org/airnow/${year}/${formattedDate}/daily_data_v2.dat`;
            
            console.log(`[DEBUG] Requesting historical data for date: ${month}/${day}/${year}`);
            console.log(`[DEBUG] URL: ${url}`);
            
            // Check cache first
            const cacheKey = `historical_${formattedDate}`;
            if (apiCache[cacheKey]) {
                console.log('[DEBUG] Using cached data');
                processHistoricalData(apiCache[cacheKey], adjustedDate);
                historicalLoader.style.display = 'none';
                return;
            }
            
            // Fetch the data
            fetch(url)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Failed to fetch historical data. Status: ${response.status}`);
                    }
                    console.log('[DEBUG] Fetch response OK');
                    return response.text();
                })
                .then(data => {
                    console.log('[DEBUG] Data received, first 200 chars:', data.substring(0, 200));
                    
                    // Cache the data
                    apiCache[cacheKey] = data;
                    
                    // Process and display the data
                    processHistoricalData(data, adjustedDate);
                })
                .catch(error => {
                    console.error('Error fetching historical data:', error);
                    historicalError.textContent = `Failed to load historical data for ${month}/${day}/${year}. Data may not be available for this date.`;
                    historicalError.style.display = 'block';
                })
                .finally(() => {
                    historicalLoader.style.display = 'none';
                });
        }

                       // Function to process historical data with date verification
        function processHistoricalData(data, requestedDate) {
            const historicalError = document.getElementById('historical-error');
            
            // ---> FIX IS HERE: Split the raw data into rows <---
            const rows = data.split('\n');

            // Parse the data
            const parsedData = rows
                .filter(row => row.trim() !== '')
                .map(row => {
                    const fields = row.split('|');
                    if (fields.length < 12) return null;
                    
                    return {
                        validDate: fields[0], // Keep original string for now
                        aqsid: fields[1],
                        siteName: fields[2],
                        parameterName: fields[3],
                        reportingUnits: fields[4],
                        value: fields[5],
                        averagingPeriod: fields[6],
                        dataSource: fields[7],
                        aqi: fields[8],
                        aqiCategory: fields[9],
                        latitude: parseFloat(fields[10]),
                        longitude: parseFloat(fields[11])
                    };
                })
                .filter(d => d !== null);

            // Set the requested date to the very beginning of the day for accurate comparison
            const startOfRequestedDay = new Date(requestedDate);
            startOfRequestedDay.setHours(0, 0, 0, 0);
            
            // Filter data to only include entries that match the requested date
            const matchingData = parsedData.filter(d => {
                const dateParts = d.validDate.split('/'); // "MM/DD/YY"
                if (dateParts.length !== 3) return false; // Skip invalid date formats
                
                const month = parseInt(dateParts[0], 10) - 1; // Month is 0-indexed
                const day = parseInt(dateParts[1], 10);
                const year = 2000 + parseInt(dateParts[2], 10); // Assumes 21st century
                
                const dataDate = new Date(year, month, day);
                dataDate.setHours(0, 0, 0, 0);
                
                // Compare the timestamps of the dates (ignoring time)
                return dataDate.getTime() === startOfRequestedDay.getTime();
            });
            
            if (matchingData.length === 0) {
                historicalError.textContent = `No data was found for ${requestedDate.toLocaleDateString()}. Data may not be available for this date.`;
                historicalError.style.display = 'block';
                // Clear any old data from the map and table
                historicalMarkers.clearLayers();
                document.getElementById('historical-table-container').innerHTML = `<p>Select a date and parameter to view historical data</p>`;
                return;
            }
            
            // Filter for Mississippi sites only
            const mississippiSites = Object.keys(siteLocations);
            const mississippiData = matchingData.filter(d => 
                mississippiSites.includes(d.siteName) || 
                (d.dataSource && d.dataSource.includes('Mississippi'))
            );
            
            if (mississippiData.length === 0) {
                historicalError.textContent = `No Mississippi air quality data available for ${requestedDate.toLocaleDateString()}.`;
                historicalError.style.display = 'block';
                return;
            }
            
            // Display the filtered data
            displayHistoricalData(mississippiData);
        }

        // Function to display historical data (modified to accept already processed data)
        function displayHistoricalData(mississippiData) {
            // Group parameters for the dropdown
            const parameters = [...new Set(mississippiData.map(d => d.parameterName))];
            const select = document.getElementById('historical-parameter-select');
            select.innerHTML = '';
            
            parameters.forEach(param => {
                const option = document.createElement('option');
                option.value = param;
                option.textContent = param;
                select.appendChild(option);
            });
            
            // Set default parameter if available
            if (parameters.includes('OZONE-8HR')) {
                select.value = 'OZONE-8HR';
            } else if (parameters.length > 0) {
                select.value = parameters[0];
            }
            
            // Update map and table with the selected parameter
            updateHistoricalMapAndTable(mississippiData, select.value);
            
            // Add change event listener to parameter select
            select.addEventListener('change', () => {
                updateHistoricalMapAndTable(mississippiData, select.value);
            });
            
            // Make sure the map is correctly sized
            setTimeout(() => historicalMap.invalidateSize(), 100);
        }
        
        // Function to update historical map and table with AQI values in markers
        function updateHistoricalMapAndTable(data, selectedParameter) {
            const filteredData = data.filter(d => d.parameterName === selectedParameter);
            historicalMarkers.clearLayers();

            filteredData.forEach(d => {
                // Prioritize using the AQI value from the data file if it's valid
                if (d.aqi && d.aqi !== '-999') {
                    let location;
                    if (siteLocations[d.siteName]) {
                        location = siteLocations[d.siteName];
                    } else if (d.latitude && d.longitude) {
                        location = { lat: d.latitude, lng: d.longitude };
                    } else {
                        return; // Skip if no location
                    }

                    const aqiValue = parseInt(d.aqi, 10);
                    const categoryNum = parseInt(d.aqiCategory, 10);
                    let quality = 'Unknown';
                    let markerColor = 'gray';
                    let textColor = 'white';

                    // Determine quality and color based on the category number from the data
                    switch (categoryNum) {
                        case 0: quality = 'Good'; markerColor = '#00e400'; textColor = 'black'; break;
                        case 1: quality = 'Moderate'; markerColor = '#ffff00'; textColor = 'black'; break;
                        case 2: quality = 'Unhealthy for Sensitive Groups'; markerColor = '#ff7e00'; break;
                        case 3: quality = 'Unhealthy'; markerColor = '#ff0000'; break;
                        case 4: quality = 'Very Unhealthy'; markerColor = '#99004c'; break;
                        case 5: quality = 'Hazardous'; markerColor = '#7e0023'; break;
                    }

                    // Create the marker icon HTML to display the AQI value
                    const iconHtml = `<div style="
                        background-color: ${markerColor}; 
                        border-radius: 50%; 
                        width: 35px; /* Slightly larger for AQI text */
                        height: 35px; 
                        display: flex; 
                        flex-direction: column;
                        justify-content: center; 
                        align-items: center; 
                        color: ${textColor}; 
                        font-weight: bold; 
                        border: 2px solid white;
                        box-shadow: 0 1px 3px rgba(0,0,0,0.3);
                        font-size: 9px;
                        line-height: 1;
                        padding-top: 2px;
                    ">AQI<div style="font-size: 14px; margin-top: -2px;">${aqiValue}</div></div>`;
                    
                    const marker = L.marker([location.lat, location.lng], {
                        icon: L.divIcon({
                            html: iconHtml,
                            className: 'custom-div-icon',
                            iconSize: [35, 35],
                            iconAnchor: [17, 17]
                        })
                    }).addTo(historicalMarkers);

                    // Create popup with BOTH AQI and concentration for full context
                    const popupContent = `
                        <div style="min-width: 250px;">
                            <h3>${d.siteName}</h3>
                            <p><strong>Quality:</strong> ${quality}</p>
                            <p><strong>AQI Value:</strong> ${aqiValue}</p>
                            <p><strong>Concentration:</strong> ${d.value} ${d.reportingUnits}</p>
                            <p><strong>Date:</strong> ${d.validDate}</p>
                            <p><strong>Data Source:</strong> ${d.dataSource}</p>
                        </div>
                    `;
                    marker.bindPopup(popupContent);
                }
            });

            // Update the data table
            updateHistoricalDataTable(filteredData, selectedParameter);
        }
        
                // Function to update historical data table to show both AQI and Concentration
        function updateHistoricalDataTable(data, parameter) {
            const tableContainer = document.getElementById('historical-table-container');
            
            if (data.length === 0) {
                tableContainer.innerHTML = `<p>No data available for ${parameter} on this date.</p>`;
                return;
            }
            
            data.sort((a, b) => a.siteName.localeCompare(b.siteName));
            
            // Modified table header to include AQI and clarify concentration
            let tableHTML = `
                <table class="data-table" style="width: 100%; border-collapse: collapse; margin-top: 20px;">
                    <thead>
                        <tr>
                            <th style="padding: 8px; border: 1px solid #ddd; background-color: #f2f2f2;">Site Name</th>
                            <th style="padding: 8px; border: 1px solid #ddd; background-color: #f2f2f2;">AQI</th>
                            <th style="padding: 8px; border: 1px solid #ddd; background-color: #f2f2f2;">Concentration</th>
                            <th style="padding: 8px; border: 1px solid #ddd; background-color: #f2f2f2;">Units</th>
                            <th style="padding: 8px; border: 1px solid #ddd; background-color: #f2f2f2;">Quality</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            data.forEach(d => {
                // Only create a row if there is a valid AQI value
                if (d.aqi && d.aqi !== '-999') {
                    const categoryNum = parseInt(d.aqiCategory);
                    let quality = 'Unknown';
                    let backgroundColor = 'gray';
                    let textColor = 'white';

                    switch (categoryNum) {
                        case 0: quality = 'Good'; backgroundColor = '#00e400'; textColor = 'black'; break;
                        case 1: quality = 'Moderate'; backgroundColor = '#ffff00'; textColor = 'black'; break;
                        case 2: quality = 'Unhealthy for Sensitive Groups'; backgroundColor = '#ff7e00'; break;
                        case 3: quality = 'Unhealthy'; backgroundColor = '#ff0000'; break;
                        case 4: quality = 'Very Unhealthy'; backgroundColor = '#99004c'; break;
                        case 5: quality = 'Hazardous'; backgroundColor = '#7e0023'; break;
                    }
                    
                    tableHTML += `
                        <tr>
                            <td style="padding: 8px; border: 1px solid #ddd;">${d.siteName}</td>
                            <td style="padding: 8px; border: 1px solid #ddd; text-align: center; font-weight: bold;">${d.aqi}</td>
                            <td style="padding: 8px; border: 1px solid #ddd; text-align: right;">${d.value}</td>
                            <td style="padding: 8px; border: 1px solid #ddd;">${d.reportingUnits}</td>
                            <td style="padding: 8px; border: 1px solid #ddd; background-color: ${backgroundColor}; color: ${textColor};">${quality}</td>
                        </tr>
                    `;
                }
            });
            
            tableHTML += `
                    </tbody>
                </table>
                <p style="margin-top: 10px; font-style: italic;">Historical data for date: ${data[0].validDate}</p>
            `;
            
            tableContainer.innerHTML = tableHTML;
        }

        // Chart variables
        const chartContainer = document.querySelector('.chart-container');
        const charts = [];
        
        // Function to fetch trend data
        async function fetchTrendData(area) {
            const trendsLoader = document.getElementById('trends-loader');
            const trendsError = document.getElementById('trends-error');
            
            // Show loader
            trendsLoader.style.display = 'block';
            trendsError.style.display = 'none';
            
            try {
                // Check cache
                const cacheKey = 'trends_data';
                if (apiCache[cacheKey]) {
                    displayTrendData(apiCache[cacheKey], area);
                    trendsLoader.style.display = 'none';
                    return;
                }
                
                const response = await fetch('https://s3-us-west-1.amazonaws.com//files.airnowtech.org/airnow/today/ten_day_lookback.dat');
                if (!response.ok) {
                    throw new Error('Failed to fetch trend data. Server returned status: ' + response.status);
                }
                
                const data = await response.text();
                
                // Cache the response
                apiCache[cacheKey] = data;
                
                // Display the data
                displayTrendData(data, area);
            } catch (error) {
                console.error('Error fetching trend data:', error);
                trendsError.textContent = 'Failed to load trend data. Please try again later. Error: ' + error.message;
                trendsError.style.display = 'block';
            } finally {
                trendsLoader.style.display = 'none';
            }
        }
        
        // Function to display trend data
        function displayTrendData(data, selectedArea) {
            const lines = data.trim().split('\n');
            const parsedData = lines.map(line => line.split('|'));
            
            const areaData = parsedData.filter(entry => entry[1] === selectedArea && entry[2] === 'MS' && entry[3] !== 'OZONE-1HR');
            renderCharts(areaData);
        }
        
        // Function to render charts - revised with direct hex color values
        function renderCharts(data) {
            clearCharts();
            
            if (data.length === 0) {
                chartContainer.innerHTML = '<p>No data available for the selected area.</p>';
                return;
            }

                        // Sort data by date within each parameter
            data.sort((a, b) => new Date(a[0]) - new Date(b[0]));
            
            const parameters = [...new Set(data.map(entry => entry[3]))];
            parameters.forEach(parameter => {
                const parameterData = data.filter(entry => entry[3] === parameter);
                parameterData.sort((a, b) => new Date(a[0]) - new Date(b[0]));
                
                const dates = parameterData.map(entry => {
                    const date = new Date(entry[0]);
                    return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                });
                
                const values = parameterData.map(entry => parseFloat(entry[7]) || null);
                
                // Apply individual colors to each bar based on AQI value
                const colors = values.map(value => {
                    // Use hex values directly instead of CSS variables
                    if (value <= 50) return '#00e400'; // Good
                    else if (value <= 100) return '#ffff00'; // Moderate
                    else if (value <= 150) return '#ff7e00'; // Unhealthy for Sensitive Groups
                    else if (value <= 200) return '#ff0000'; // Unhealthy
                    else if (value <= 300) return '#99004c'; // Very Unhealthy
                    else return '#7e0023'; // Hazardous
                });
                
                const chartDiv = document.createElement('div');
                chartDiv.style.width = '100%';
                chartDiv.style.maxWidth = '800px';
                chartDiv.style.margin = '20px auto';
                chartContainer.appendChild(chartDiv);
                
                const canvas = document.createElement('canvas');
                chartDiv.appendChild(canvas);
                
                const ctx = canvas.getContext('2d');
                const chart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: dates,
                        datasets: [{
                            label: parameter,
                            data: values,
                            backgroundColor: colors, // Direct hex values
                            borderColor: colors,     // Direct hex values
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            title: {
                                display: true,
                                text: `${parameter} Trend for ${parameterData[0][1]}, MS`,
                                font: {
                                    size: 16,
                                    weight: 'bold'
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    afterLabel: function(context) {
                                        const value = context.raw;
                                        return `Category: ${getAQICategory(value)}`;
                                    },
                                }
                            },
                            legend: {
                                display: false // Hide the legend since colors vary by bar
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'AQI Value'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Date'
                                }
                            }
                        }
                    }
                });
                
                charts.push(chart);
                
                // Add a legend below each chart
                const legendDiv = document.createElement('div');
                legendDiv.style.display = 'flex';
                legendDiv.style.flexWrap = 'wrap';
                legendDiv.style.justifyContent = 'center';
                legendDiv.style.margin = '10px auto';
                legendDiv.style.maxWidth = '800px';
                chartDiv.appendChild(legendDiv);
                
                // Create a small legend with actual colors (not CSS variables)
                const categories = [
                    { name: 'Good (0-50)', color: '#00e400' },
                    { name: 'Moderate (51-100)', color: '#ffff00' },
                    { name: 'Unhealthy for Sensitive Groups (101-150)', color: '#ff7e00' },
                    { name: 'Unhealthy (151-200)', color: '#ff0000' },
                    { name: 'Very Unhealthy (201-300)', color: '#99004c' },
                    { name: 'Hazardous (301+)', color: '#7e0023' }
                ];
                
                categories.forEach(category => {
                    const item = document.createElement('div');
                    item.style.display = 'flex';
                    item.style.alignItems = 'center';
                    item.style.margin = '3px 8px';
                    
                    const colorBox = document.createElement('span');
                    colorBox.style.width = '15px';
                    colorBox.style.height = '15px';
                    colorBox.style.backgroundColor = category.color;
                    colorBox.style.display = 'inline-block';
                    colorBox.style.marginRight = '5px';
                    
                    const name = document.createElement('span');
                    name.textContent = category.name;
                    name.style.fontSize = '0.75rem';
                    
                    item.appendChild(colorBox);
                    item.appendChild(name);
                    legendDiv.appendChild(item);
                });
            });
        }
        
        // Function to clear charts
        function clearCharts() {
            charts.forEach(chart => chart.destroy());
            chartContainer.innerHTML = '';
            charts.length = 0;
        }
        
        // Function to get color for AQI value
        function getColorForAQI(aqi) {
            if (aqi <= 50) return 'var(--good-color)';
            else if (aqi <= 100) return 'var(--moderate-color)';
            else if (aqi <= 150) return 'var(--unhealthy-sensitive-color)';
            else if (aqi <= 200) return 'var(--unhealthy-color)';
            else if (aqi <= 300) return 'var(--very-unhealthy-color)';
            else return 'var(--hazardous-color)';
        }
        
        // Function to update forecasts
        function updateForecasts() {
            console.log('[DEBUG] Updating forecasts...');
            const forecastLoader = document.getElementById('forecast-loader');
            const forecastError = document.getElementById('forecast-error');
            
            // Clear any previous errors
            forecastError.style.display = 'none';
            
            // Show loader
            forecastLoader.style.display = 'block';
            
            // Update the current date display
            const currentDateElement = document.createElement('div');
            currentDateElement.style.textAlign = 'center';
            currentDateElement.style.margin = '10px 0';
            currentDateElement.style.fontWeight = 'bold';
            
            const now = new Date();
            currentDateElement.textContent = `Forecast as of: ${now.toLocaleDateString('en-US', {
                weekday: 'long',
                year: 'numeric',
                month: 'long',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            })}`;
            
            // Insert the current date element before the forecast container
            const forecastContainer = document.getElementById('forecast-container');
            const parent = forecastContainer.parentNode;
            
            // Remove any existing date display
            const existingDateElement = document.getElementById('forecast-current-date');
            if (existingDateElement) {
                parent.removeChild(existingDateElement);
            }
            
            // Add the new date element with an ID for future reference
            currentDateElement.id = 'forecast-current-date';
            parent.insertBefore(currentDateElement, forecastContainer);
            
            // Start fetching forecasts for each location
            Promise.all([
                fetchForecast('38632', 'forecast-hernando'), // Hernando zip code
                fetchForecast('39201', 'forecast-jackson'),  // Jackson zip code
                fetchForecast('39501', 'forecast-gulf-coast') // Gulf Coast zip code
            ])
            .then(() => {
                console.log('[DEBUG] All forecasts updated successfully');
                forecastLoader.style.display = 'none';
            })
            .catch(error => {
                console.error('[ERROR] Error updating forecasts:', error);
                forecastError.textContent = 'Failed to load forecast data. Please try again later. Error: ' + error.message;
                forecastError.style.display = 'block';
                forecastLoader.style.display = 'none';
            });
        }
        
        // Function to fetch forecast data for a location
        async function fetchForecast(zipCode, elementId) {
            const forecastLoader = document.getElementById('forecast-loader');
            const forecastError = document.getElementById('forecast-error');
            
            // Show loader
            forecastLoader.style.display = 'block';
            
            const apiKey = 'F20E6AAA-D56F-E511-A968DF4E5E4316FD';
            const currentDate = new Date().toISOString().split('T')[0];
            const apiUrl = `https://www.airnowapi.org/aq/forecast/zipCode/?format=application/json&zipCode=${zipCode}&date=${currentDate}&distance=25&API_KEY=${apiKey}`;
            const pollutant = document.getElementById('pollutant-select').value;
            
            // DEBUG: Log request information
            console.log(`[DEBUG] Forecast request: ${zipCode} - ${pollutant} - Current date: ${currentDate}`);
            console.log(`[DEBUG] Full API URL: ${apiUrl}`);
            
            // Check cache
            const cacheKey = `forecast_${zipCode}_${pollutant}_${currentDate}`;
            if (apiCache[cacheKey]) {
                console.log(`[DEBUG] Using cached forecast data for ${zipCode}`);
                displayForecast(apiCache[cacheKey], elementId, pollutant);
                return;
            }
            
            try {
                console.log(`[DEBUG] Fetching fresh forecast data for ${zipCode}`);
                const response = await fetch(apiUrl);
                
                if (!response.ok) {
                    throw new Error(`Failed to fetch forecast for ${zipCode}. Status: ${response.status}`);
                }
                
                const data = await response.json();
                
                // DEBUG: Log the raw API response
                console.log(`[DEBUG] Raw API response for ${zipCode}:`, data);
                
                if (data && data.length > 0) {
                    // DEBUG: Log the first date from response
                    console.log(`[DEBUG] First forecast date from API: ${data[0].DateForecast}`);
                }
                
                // Cache the response
                apiCache[cacheKey] = data;
                
                // Display the forecast
                displayForecast(data, elementId, pollutant);
            } catch (error) {
                console.error(`[ERROR] Error fetching forecast for ${zipCode}:`, error);
                document.getElementById(elementId).innerHTML = `
                    <div class="forecast-item">
                        <h3>Forecast Unavailable</h3>
                        <p>Could not load forecast data for this location.</p>
                    </div>
                `;
                forecastError.textContent = `Failed to load forecast for ${zipCode}: ${error.message}`;
                forecastError.style.display = 'block';
            } finally {
                forecastLoader.style.display = 'none';
            }
        }

    // Function to display forecast - WITH HEALTH INFORMATION
        function displayForecast(data, elementId, pollutant) {
            const container = document.getElementById(elementId);
            if (!data || data.length === 0) {
                container.innerHTML = `<div class="forecast-item"><h3>No Forecast Available</h3><p>No forecast data available for this location.</p></div>`;
                return;
            }
            
            const filteredData = data.filter(forecast => forecast.ParameterName === pollutant);
            if (filteredData.length === 0) {
                container.innerHTML = `<div class="forecast-item"><h3>${data[0].ReportingArea}</h3><p>No ${pollutant} forecast available for this location.</p></div>`;
                return;
            }
            
            let forecastHTML = '';
            filteredData.forEach(forecast => {
                const categoryClass = forecast.Category.Name.toLowerCase().replace(/ /g, '-');
                const categoryInfo = aqiCategoryInfo[forecast.Category.Name];

                const [year, month, day] = forecast.DateForecast.split('-').map(num => parseInt(num, 10));
                const dateObj = new Date(year, month - 1, day, 12, 0, 0, 0);
                const formattedDate = dateObj.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
                
                forecastHTML += `
                    <div class="forecast-item ${categoryClass}">
                        <h3>${forecast.ReportingArea}</h3>
                        <p><strong>Date:</strong> ${formattedDate}</p>
                        ${forecast.AQI !== -1 ? `<p style="font-size: 1.5rem; font-weight: bold; margin: 5px 0;">AQI: ${forecast.AQI}</p>` : ''}
                        <p><strong>Category:</strong> ${forecast.Category.Name}</p>
                        ${categoryInfo ? `<p style="font-size: 0.9rem; text-align: left; margin-top: 10px;"><em>${categoryInfo.description}</em></p>` : ''}
                        ${forecast.Discussion ? `<p style="font-size: 0.9rem; text-align: left; margin-top: 10px;"><strong>Discussion:</strong> ${forecast.Discussion}</p>` : ''}
                    </div>
                `;
            });
            
            container.innerHTML = forecastHTML;
            console.log(`[DEBUG] Forecast display complete for ${elementId}`);
        }
        
        // Function to share content
        function shareContent(contentType) {
            let title, text, url;
            
            switch (contentType) {
                case 'map':
                    const parameter = document.getElementById('parameter-select').value;
                    title = `Mississippi Air Quality: Current ${parameter} Data`;
                    text = `Check out the current ${parameter} air quality data for Mississippi.`;
                    break;
                case 'historical':
                    const historicalParameter = document.getElementById('historical-parameter-select').value;
                    const historicalDate = document.getElementById('historical-date').value;
                    title = `Mississippi Air Quality: Historical ${historicalParameter} Data (${historicalDate})`;
                    text = `View historical ${historicalParameter} air quality data for Mississippi from ${historicalDate}.`;
                    break;
                case 'trends':
                    const area = document.getElementById('area-select').value;
                    title = `Mississippi Air Quality Trends: ${area}`;
                    text = `View the air quality trends for ${area}, Mississippi.`;
                    break;
                case 'forecast':
                    const pollutant = document.getElementById('pollutant-select').value;
                    title = `Mississippi Air Quality Forecast: ${pollutant}`;
                    text = `Check out the ${pollutant} air quality forecast for Mississippi.`;
                    break;
                default:
                    title = 'Mississippi Air Quality Dashboard';
                    text = 'Check out the air quality data for Mississippi.';
            }
            
            url = window.location.href;
            
            if (navigator.share) {
                navigator.share({
                    title: title,
                    text: text,
                    url: url
                })
                .then(() => console.log('Shared successfully'))
                .catch(error => console.error('Share failed:', error));
            } else {
                // Fallback for browsers that don't support the Web Share API
                prompt('Copy this URL to share:', url);
            }
        }
        
        function checkOzoneNoteVisibility() {
            const ozoneNote = document.getElementById('ozone-season-note');
            const pollutantSelect = document.getElementById('pollutant-select');
            if (pollutantSelect.value === 'O3') {
                ozoneNote.style.display = 'block';
            } else {
                ozoneNote.style.display = 'none';
            }
        }
        
            // Function to handle tab switching
            function openTab(evt, tabName) {
            // Hide all tab content
            const tabcontent = document.getElementsByClassName("tabcontent");
            for (let i = 0; i < tabcontent.length; i++) {
                tabcontent[i].style.display = "none";
            }
            
            // Remove active class from all tab buttons
            const tablinks = document.getElementsByClassName("tablinks");
            for (let i = 0; i < tablinks.length; i++) {
                tablinks[i].className = tablinks[i].className.replace(" active", "");
            }
            
            // Show the current tab content and add active class to the button
            document.getElementById(tabName).style.display = "block";
            evt.currentTarget.className += " active";
            
            // Perform tab-specific actions
            if (tabName === 'AirQualityData') {
                // Update map size after a short delay to ensure the container is fully rendered
                setTimeout(() => map.invalidateSize(), 100);
            } else if (tabName === 'HistoricalData') {
                // Resize historical map
                setTimeout(() => historicalMap.invalidateSize(), 100);
            } else if (tabName === 'Forecast') {
                // Trigger forecast update
                updateForecasts();
                // --- THIS IS THE NEW LINE ---
                // Check if the ozone note should be visible immediately
                checkOzoneNoteVisibility();
            }
        }

        // New functions for historical trend analysis
        async function fetchHistoricalTrendData(area, startDate, endDate, analysisType) {
            const trendsLoader = document.getElementById('trends-loader');
            const trendsError = document.getElementById('trends-error');
            
            // Show loader
            trendsLoader.style.display = 'block';
            trendsError.style.display = 'none';
            
            try {
                // Format dates for caching
                const formattedStartDate = formatDate(startDate);
                const formattedEndDate = formatDate(endDate);
                
                // Use a cache key that includes all parameters
                const cacheKey = `trend_data_${area}_${formattedStartDate}_${formattedEndDate}_${analysisType}`;
                
                // Check if we have cached data
                if (apiCache[cacheKey]) {
                    console.log('Using cached trend data');
                    processAnalysisData(apiCache[cacheKey], area, analysisType);
                    trendsLoader.style.display = 'none';
                    return;
                }
                
                // Generate array of all dates in the range
                const dateArray = [];
                const currentDate = new Date(startDate);
                const lastDate = new Date(endDate);
                
                while (currentDate <= lastDate) {
                    dateArray.push(new Date(currentDate));
                    currentDate.setDate(currentDate.getDate() + 1);
                }
                
                console.log(`Fetching data for ${dateArray.length} days from ${startDate} to ${endDate}`);
                
                // Fetch data for each date in the range
                const allData = [];
                const fetchPromises = [];
                
                // Using Promise.all to fetch data for all dates in parallel
                for (const date of dateArray) {
                    const year = date.getFullYear();
                    const month = String(date.getMonth() + 1).padStart(2, '0');
                    const day = String(date.getDate()).padStart(2, '0');
                    const formattedDate = `${year}${month}${day}`;
                    
                    const url = `https://s3-us-west-1.amazonaws.com//files.airnowtech.org/airnow/${year}/${formattedDate}/daily_data_v2.dat`;
                    
                    // Create a promise that fetches data and catches errors if a request fails
                    const fetchPromise = fetch(url)
                        .then(response => {
                            if (!response.ok) {
                                console.log(`No data available for ${formattedDate}`);
                                return null; // Return null for dates with no data
                            }
                            return response.text();
                        })
                        .then(data => {
                            if (!data) return; // Skip processing if no data
                            
                            // Parse the data
                            const rows = data.split('\n');
                            const parsedData = rows
                                .filter(row => row.trim() !== '')
                                .map(row => {
                                    const fields = row.split('|');
                                    if (fields.length < 12) return null;
                                    
                                    return {
                                        validDate: fields[0],
                                        aqsid: fields[1],
                                        siteName: fields[2],
                                        parameterName: fields[3],
                                        reportingUnits: fields[4],
                                        value: fields[5],
                                        averagingPeriod: fields[6],
                                        dataSource: fields[7],
                                        aqi: fields[8],
                                        aqiCategory: fields[9],
                                        latitude: parseFloat(fields[10]),
                                        longitude: parseFloat(fields[11])
                                    };
                                })
                                .filter(d => d !== null);
                            
                            // Filter out OZONE-1HR records
                            const filteredData = parsedData.filter(d => d.parameterName !== 'OZONE-1HR');
                            
                            // Filter for Mississippi sites and the selected area
                            const mississippiSites = Object.keys(siteLocations);
                            const areaData = filteredData.filter(d => {
                                // Check if this site is in Mississippi and matches the selected area
                                const isMississippiSite = mississippiSites.includes(d.siteName) || 
                                                        (d.dataSource && d.dataSource.includes('Mississippi'));
                                
                                // Check if this site is in the selected area
                                const isInSelectedArea = isStationInArea(d.siteName, area);
                                
                                return isMississippiSite && isInSelectedArea;
                            });
                            
                            // Convert the data to our analysis format
                            const formattedData = areaData.map(d => {
                                // Parse the validDate (MM/DD/YY) from the file content
                                const dateParts = d.validDate.split('/'); // ["MM", "DD", "YY"]
                                if (dateParts.length !== 3) {
                                    console.warn(`Skipping record with invalid date format in file: ${d.validDate}`);
                                    return null; // Skip if date format is wrong
                                }
                                const monthStr = dateParts[0].padStart(2, '0');
                                const dayStr = dateParts[1].padStart(2, '0');
                                // Construct full year (assuming 20xx) - adjust if older data is possible
                                const yearStr = `20${dateParts[2]}`;

                                // Create the standardized YYYY-MM-DD date string based on the file's actual validDate
                                const actualValidDateStr = `${yearStr}-${monthStr}-${dayStr}`;

                    // *** Crucially, filter here: Only include data whose actual valid date
                                // *** falls within the user's selected local date range. ***
                                // Create Date object for the record's date (at noon local)
                                const actualValidDate = new Date(yearStr, parseInt(monthStr) - 1, parseInt(dayStr), 12, 0, 0);

                                // ----> Refined Date-Only Comparison <----
                                // Set start/end times to 00:00:00 to compare just the date part
                                const startOfDay = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate(), 0, 0, 0, 0);
                                const endOfDay = new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate(), 23, 59, 59, 999); // End of the selected day

                                // Get the time for the record's date (already at noon)
                                const actualTime = actualValidDate.getTime();
                                const startTime = startOfDay.getTime();
                                const endTime = endOfDay.getTime();

                                // Check if the record's actual local date/time is before the start day OR after the end day
                                if (actualTime < startTime || actualTime > endTime) {
                                    // This condition is apparently NEVER true for the 60 records
                                    console.log(`DEBUG: Skipping record (Date-Only Check)...`);
                                    return null;
                                }
                                // ----> End of Refined Comparison <----
                                // *** End of range filter ***

                                return {
                                    // Use the actualValidDateStr derived from the file content
                                    date: actualValidDateStr,
                                    parameter: d.parameterName,
                                    value: d.value,
                                    units: d.reportingUnits,
                                    area: area,
                                    siteName: d.siteName,
                                    aqi: d.aqi,
                                    aqiCategory: d.aqiCategory
                                    // originalValidDateFromFile: d.validDate // Optional: keep original if needed
                                };
                            }).filter(item => item !== null); // Filter out any skipped records (invalid format or outside range)
                            
                            // Add to our collected data
                            allData.push(...formattedData);
                        })
                        .catch(error => {
                            console.error(`Error fetching data for ${formattedDate}:`, error);
                            // Continue with other dates even if one fails
                            return null;
                        });
                    
                    fetchPromises.push(fetchPromise);
                }
                
                // Wait for all fetch operations to complete
                await Promise.all(fetchPromises);
                
                console.log(`Fetched data for all dates, total records: ${allData.length}`);
                // Cache the FILTERED data
                apiCache[cacheKey] = allData;
                processAnalysisData(allData, area, analysisType);
                
            } catch (error) {
                console.error('Error fetching historical trend data:', error);
                trendsError.textContent = 'Failed to load historical trend data. Error: ' + error.message;
                trendsError.style.display = 'block';
            } finally {
                trendsLoader.style.display = 'none';
            }
        }

        // Function to process data based on the selected analysis type
        function processAnalysisData(data, area, analysisType) {
          document.getElementById('trends-analysis-title').textContent = `Showing analysis for ${area} from ${document.getElementById('trend-start-date').value} to ${document.getElementById('trend-end-date').value}`;
            if (data.length === 0) {
                const trendsError = document.getElementById('trends-error');
                trendsError.textContent = `No data available for ${area} in the selected date range. Try expanding your date range or selecting a different area.`;
                trendsError.style.display = 'block';
                return;
            }
            
            console.log(`Processing ${data.length} records for ${analysisType} analysis`);
            
            // Process the data based on the selected analysis type
            switch(analysisType) {
                case 'time-series':
                    displayTimeSeriesChart(data, area);
                    break;
                case 'exceedance':
                    displayExceedanceAnalysis(data, area);
                    break;
                case 'monthly-avg':
                    displayMonthlyAverages(data, area);
                    break;
                case 'pollutant-comparison':
                    const selectedPollutants = getSelectedPollutants();
                    displayPollutantComparison(data, area, selectedPollutants);
                    break;
                case 'statistical':
                    displayStatisticalSummary(data, area);
                    break;
            }
        }

        // Helper function to determine if a station is in the selected area
        function isStationInArea(siteName, area) {
            // Map areas to their corresponding sites
            const areaToSites = {
                'Cleveland': ['CLEVELAND'],
                'Hattiesburg': ['Hattiesburg'],
                'Hernando': ['HERNANDO'],
                'Jackson': ['Hinds CC', 'Jackson NCORE'],
                'Meridian': ['MERIDIAN'],
                'Mississippi Gulf Coast': ['GPORT YC', 'PASCAGOULA', 'WAVELAND'],
                'Tupelo': ['TUPELOAP']
            };
            
            // Check if the site is in the selected area
            if (areaToSites[area] && areaToSites[area].includes(siteName)) {
                return true;
            }
            
            // If the area is not in our mapping or the site isn't listed, do a substring check
            return siteName.includes(area) || siteName.includes(area.toUpperCase());
        }

        // Linear scaling function for AQI calculations
        function linearScale(concentration, concLow, concHigh, aqiLow, aqiHigh) {
            return ((concentration - concLow) / (concHigh - concLow)) * (aqiHigh - aqiLow) + aqiLow;
        }

        // Function to get selected pollutants for comparison
        function getSelectedPollutants() {
            const pollutants = [];
            if (document.getElementById('compare-ozone').checked) pollutants.push('OZONE-8HR');
            if (document.getElementById('compare-pm25').checked) pollutants.push('PM2.5-24hr');
            if (document.getElementById('compare-pm10').checked) pollutants.push('PM10-24hr');
            if (document.getElementById('compare-no2').checked) pollutants.push('NO2');
            if (document.getElementById('compare-so2').checked) pollutants.push('SO2-24HR');
            if (document.getElementById('compare-co').checked) pollutants.push('CO-8hr');
            return pollutants;
        }

        // Function to display time series chart with category scale
        function displayTimeSeriesChart(data, area) {
            clearCharts();
            
            // Hide containers for other analysis types
            document.getElementById('exceedance-summary').style.display = 'none';
            document.getElementById('statistical-summary').style.display = 'none';
            
            // Group data by parameter
            const parameterGroups = {};
            data.forEach(entry => {
                if (!parameterGroups[entry.parameter]) {
                    parameterGroups[entry.parameter] = [];
                }
                parameterGroups[entry.parameter].push(entry);
            });
            
            // Create a chart for each parameter
            Object.keys(parameterGroups).forEach(parameter => {
                const parameterData = parameterGroups[parameter];
                
                // Sort by date
                parameterData.sort((a, b) => new Date(a.date) - new Date(b.date));
                
            // Prepare data for the chart
                // Format dates properly for Chart.js, ensuring correct local day display
                const formattedDates = parameterData.map(entry => {
                    // entry.date is the "YYYY-MM-DD" string representing the LOCAL day from the fetch loop
                    const [year, month, day] = entry.date.split('-').map(Number);
                    // Create a Date object representing LOCAL NOON for that day to avoid timezone shifts at midnight
                    const dateObj = new Date(year, month - 1, day, 12, 0, 0);
                    // Now format this unambiguous local date
                    return dateObj.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                });
                
                const values = parameterData.map(entry => parseFloat(entry.value));
                
                // Create chart container
                const chartDiv = document.createElement('div');
                chartDiv.style.width = '100%';
                chartDiv.style.maxWidth = '800px';
                chartDiv.style.margin = '20px auto';
                chartContainer.appendChild(chartDiv);
                
                const canvas = document.createElement('canvas');
                chartDiv.appendChild(canvas);
                
                // Get units for this parameter
                const units = getUnitsForParameter(parameter);
                
                // Generate colors based on AQI values (adjusted for concentration units)
                const colors = values.map(value => {
                    // Convert concentration to appropriate color based on parameter
                    return getColorFromConcentration(value, parameter);
                });
                
                // Create the chart - USING CATEGORY SCALE INSTEAD OF TIME SCALE
                const ctx = canvas.getContext('2d');
                const chart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: formattedDates,
                        datasets: [{
                            label: parameter,
                            data: values,
                            borderColor: '#0071bc',
                            backgroundColor: 'rgba(0, 113, 188, 0.1)',
                            borderWidth: 2,
                            pointBackgroundColor: colors,
                            pointBorderColor: colors,
                            pointRadius: 4
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            title: {
                                display: true,
                                text: `${parameter} Trend for ${area} (in ${units})`,
                                font: {
                                    size: 16,
                                    weight: 'bold'
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    // Use 'footer' callback to add more lines of information
                                    footer: function(tooltipItems) {
                                        const tooltipItem = tooltipItems[0];
                                        const value = tooltipItem.raw;
                                        const aqi = convertToAQI(value, tooltipItem.dataset.label);
                                        
                                        // Return an array of strings, each will be a new line
                                        return [
                                            `Category: ${getAQICategory(aqi)}`,
                                            `Calculated AQI: ${aqi}`
                                        ];
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                // Using category scale instead of time scale
                                title: {
                                    display: true,
                                    text: 'Date'
                                }
                            },
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: `${parameter} Value (${units})`
                                }
                            }
                        }
                    }
                });
                
                charts.push(chart);
                
                // Add a legend below the chart showing AQI color categories
                addChartLegend(chartDiv, parameter);
            });
        }

        // Helper function to convert concentration to AQI value with updated PM2.5 standards
        function convertToAQI(concentration, parameter) {
            // Implementation based on EPA's AQI breakpoints
            // Updated with the new PM2.5 standard of 9 g/m for Good category
            
            let aqi = 0;
            
            // Convert based on parameter - handling suffixes
            if (parameter.startsWith('OZONE')) {
                // 8-hour ozone in ppb
                if (concentration <= 54) {
                    aqi = linearScale(concentration, 0, 54, 0, 50);
                } else if (concentration <= 70) {
                    aqi = linearScale(concentration, 55, 70, 51, 100);
                } else if (concentration <= 85) {
                    aqi = linearScale(concentration, 71, 85, 101, 150);
                } else if (concentration <= 105) {
                    aqi = linearScale(concentration, 86, 105, 151, 200);
                } else if (concentration <= 200) {
                    aqi = linearScale(concentration, 106, 200, 201, 300);
                } else {
                    aqi = linearScale(concentration, 201, 500, 301, 500);
                }
            } else if (parameter.startsWith('PM2.5')) {
                // PM2.5 in g/m - Updated with new standard of 9 g/m
                if (concentration <= 9.0) {
                    aqi = linearScale(concentration, 0, 9.0, 0, 50);
                } else if (concentration <= 35.4) {
                    aqi = linearScale(concentration, 9.1, 35.4, 51, 100);
                } else if (concentration <= 55.4) {
                    aqi = linearScale(concentration, 35.5, 55.4, 101, 150);
                } else if (concentration <= 150.4) {
                    aqi = linearScale(concentration, 55.5, 150.4, 151, 200);
                } else if (concentration <= 250.4) {
                    aqi = linearScale(concentration, 150.5, 250.4, 201, 300);
                } else {
                    aqi = linearScale(concentration, 250.5, 500.4, 301, 500);
                }
    
            } else if (parameter.startsWith('PM10')) {
                // PM10 in g/m
                if (concentration <= 54) {
                    aqi = linearScale(concentration, 0, 54, 0, 50);
                } else if (concentration <= 154) {
                    aqi = linearScale(concentration, 55, 154, 51, 100);
                } else if (concentration <= 254) {
                    aqi = linearScale(concentration, 155, 254, 101, 150);
                } else if (concentration <= 354) {
                    aqi = linearScale(concentration, 255, 354, 151, 200);
                } else if (concentration <= 424) {
                    aqi = linearScale(concentration, 355, 424, 201, 300);
                } else {
                    aqi = linearScale(concentration, 425, 604, 301, 500);
                }
            } else if (parameter.startsWith('CO')) {
                // CO in ppm
                if (concentration <= 4.4) {
                    aqi = linearScale(concentration, 0, 4.4, 0, 50);
                } else if (concentration <= 9.4) {
                    aqi = linearScale(concentration, 4.5, 9.4, 51, 100);
                } else if (concentration <= 12.4) {
                    aqi = linearScale(concentration, 9.5, 12.4, 101, 150);
                } else if (concentration <= 15.4) {
                    aqi = linearScale(concentration, 12.5, 15.4, 151, 200);
                } else if (concentration <= 30.4) {
                    aqi = linearScale(concentration, 15.5, 30.4, 201, 300);
                } else {
                    aqi = linearScale(concentration, 30.5, 50.4, 301, 500);
                }
            } else if (parameter.startsWith('SO2')) {
                // SO2 in ppb
                if (concentration <= 35) {
                    aqi = linearScale(concentration, 0, 35, 0, 50);
                } else if (concentration <= 75) {
                    aqi = linearScale(concentration, 36, 75, 51, 100);
                } else if (concentration <= 185) {
                    aqi = linearScale(concentration, 76, 185, 101, 150);
                } else if (concentration <= 304) {
                    aqi = linearScale(concentration, 186, 304, 151, 200);
                } else if (concentration <= 604) {
                    aqi = linearScale(concentration, 305, 604, 201, 300);
                } else {
                    aqi = linearScale(concentration, 605, 1004, 301, 500);
                }
            } else if (parameter.startsWith('NO2')) {
                // NO2 in ppb
                if (concentration <= 53) {
                    aqi = linearScale(concentration, 0, 53, 0, 50);
                } else if (concentration <= 100) {
                    aqi = linearScale(concentration, 54, 100, 51, 100);
                } else if (concentration <= 360) {
                    aqi = linearScale(concentration, 101, 360, 101, 150);
                } else if (concentration <= 649) {
                    aqi = linearScale(concentration, 361, 649, 151, 200);
                } else if (concentration <= 1249) {
                    aqi = linearScale(concentration, 650, 1249, 201, 300);
                } else {
                    aqi = linearScale(concentration, 1250, 2049, 301, 500);
                }
            } else {
                // Generic scale if parameter not recognized
                if (concentration <= 50) {
                    aqi = concentration;
                } else {
                    aqi = concentration;
                }
            }
            
            // Round to nearest integer
            return Math.round(aqi);
        }

        // Helper function to get appropriate units for each parameter
        function getUnitsForParameter(parameter) {
            if (parameter.startsWith('OZONE') || parameter.startsWith('NO2') || parameter.startsWith('SO2')) {
                return 'ppb';
            } else if (parameter.startsWith('PM2.5') || parameter.startsWith('PM10')) {
                return 'g/m';
            } else if (parameter.startsWith('CO')) {
                return 'ppm';
            } else {
                return '';
            }
        }

        // Helper function to get color based on concentration value
        function getColorFromConcentration(value, parameter) {
            // Convert concentration to AQI
            const aqi = convertToAQI(value, parameter);
            
            // Return color based on AQI
            if (aqi <= 50) return '#00e400';          // Good
            else if (aqi <= 100) return '#ffff00';    // Moderate
            else if (aqi <= 150) return '#ff7e00';    // Unhealthy for Sensitive Groups
            else if (aqi <= 200) return '#ff0000';    // Unhealthy
            else if (aqi <= 300) return '#99004c';    // Very Unhealthy
            else return '#7e0023';                    // Hazardous
        }

            // REVISED function for exceedance analysis - With better browser compatibility
            function displayExceedanceAnalysis(data, area) {
            clearCharts();
            document.getElementById('statistical-summary').style.display = 'none';
            
            const exceedanceSummary = document.getElementById('exceedance-summary');
            exceedanceSummary.style.display = 'block';
            const exceedanceContent = document.getElementById('exceedance-content');
            
            let summaryHTML = '';

            // More compatible way to group data
            const parameterGroups = {};
            data.forEach(entry => {
                if (!parameterGroups[entry.parameter]) {
                    parameterGroups[entry.parameter] = [];
                }
                parameterGroups[entry.parameter].push(entry);
            });

            Object.keys(parameterGroups).forEach(parameter => {
                const parameterData = parameterGroups[parameter];
                const units = getUnitsForParameter(parameter);
                
                let exceedanceThreshold;
                if (parameter.startsWith('OZONE')) { exceedanceThreshold = 71; }
                else if (parameter.startsWith('PM2.5')) { exceedanceThreshold = 35.5; }
                else if (parameter.startsWith('PM10')) { exceedanceThreshold = 155; }
                else if (parameter.startsWith('NO2')) { exceedanceThreshold = 101; }
                else if (parameter.startsWith('SO2')) { exceedanceThreshold = 76; }
                else if (parameter.startsWith('CO')) { exceedanceThreshold = 9.5; }
                else { exceedanceThreshold = 101; }

                const exceedances = parameterData.filter(d => parseFloat(d.value) >= exceedanceThreshold);
                
                const monthlyCounts = {};
                exceedances.forEach(day => {
                    const date = new Date(day.date + 'T12:00:00');
                    const monthYear = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                    if (!monthlyCounts[monthYear]) {
                        monthlyCounts[monthYear] = 0;
                    }
                    monthlyCounts[monthYear]++;
                });

                let exceedanceDatesHTML = '<p>No exceedance days (AQI > 100) were recorded in this period.</p>';
                if (exceedances.length > 0) {
                    const dateList = exceedances.map(e => `<li>${new Date(e.date + 'T12:00:00').toLocaleDateString('en-US')} (Value: ${e.value} ${units})</li>`).join('');
                    exceedanceDatesHTML = `<details><summary style="cursor: pointer;">View ${exceedances.length} Exceedance Date(s)</summary><ul>${dateList}</ul></details>`;
                }

                summaryHTML += `
                    <div class="parameter-exceedance">
                        <h4>${parameter} Exceedance Summary for ${area}</h4>
                        <p>Total days analyzed: <strong>${parameterData.length}</strong></p>
                        <p>Total Exceedance Days (AQI > 100): <strong>${exceedances.length}</strong></p>
                        ${exceedanceDatesHTML}
                    </div>
                `;
                
                const chartDiv = document.createElement('div');
                chartDiv.style.width = '100%';
                chartDiv.style.maxWidth = '1100px';
                chartDiv.style.margin = '20px auto';
                chartContainer.appendChild(chartDiv);
                
                const canvas = document.createElement('canvas');
                chartDiv.appendChild(canvas);
                
                const months = Object.keys(monthlyCounts).sort();
                const monthLabels = months.map(my => new Date(my + '-01T12:00:00').toLocaleDateString('en-US', { month: 'short', year: 'numeric' }));
                const exceedanceCounts = months.map(m => monthlyCounts[m]);

                new Chart(canvas.getContext('2d'), {
                    type: 'bar',
                    data: {
                        labels: monthLabels,
                        datasets: [{
                            label: 'Exceedance Days (AQI > 100)',
                            data: exceedanceCounts,
                            backgroundColor: '#ff7e00',
                        }]
                    },
                    options: {
                        plugins: {
                            title: { display: true, text: `Monthly Exceedance Days for ${parameter}` },
                        },
                        scales: {
                            y: { 
                                beginAtZero: true, 
                                title: { display: true, text: 'Number of Exceedance Days' },
                                ticks: { stepSize: 1 }
                            }
                        }
                    }
                });
            });
            exceedanceContent.innerHTML = summaryHTML;
        }

                // Updated function for monthly averages with concentration values
                function displayMonthlyAverages(data, area) {
                    clearCharts();
                    document.getElementById('exceedance-summary').style.display = 'none';
                    document.getElementById('statistical-summary').style.display = 'none';

                    // ---> Add Log: See exactly what dates are coming IN to this function
                    console.log("DEBUG: Data received by displayMonthlyAverages:", data.map(d => d.date));
                    // ---> End Log

                    const parameterGroups = {};
                    data.forEach(entry => {
                        if (!parameterGroups[entry.parameter]) {
                            parameterGroups[entry.parameter] = [];
                        }
                        parameterGroups[entry.parameter].push(entry);
                    });

                    Object.keys(parameterGroups).forEach(parameter => {
                        const parameterData = parameterGroups[parameter];
                        const units = getUnitsForParameter(parameter);
                        const monthlyData = {};

                        parameterData.forEach(entry => {
                            // ---> Add Log: Check the date parsing and month extraction
                            const entryDateStr = entry.date; // Should be "YYYY-MM-DD"
                            const date = new Date(entryDateStr + 'T12:00:00'); // Create date at local noon
                            const year = date.getFullYear();
                            const month = date.getMonth(); // 0-indexed (0 = Jan, 1 = Feb, 2 = Mar)
                            const monthYear = `${year}-${String(month + 1).padStart(2, '0')}`; // YYYY-MM

                            console.log(`DEBUG: Processing entry date: ${entryDateStr}, Parsed Month: ${month}, MonthYear Key: ${monthYear}`);
                            // ---> End Log

                            if (!monthlyData[monthYear]) {
                                monthlyData[monthYear] = { sum: 0, count: 0, dates: [] };
                            }
                            monthlyData[monthYear].sum += parseFloat(entry.value);
                            monthlyData[monthYear].count++;
                            monthlyData[monthYear].dates.push(date);
                        });

                        // ---> Add Log: Inspect the generated monthlyData keys
                        console.log(`DEBUG: Monthly data keys generated for ${parameter}:`, Object.keys(monthlyData));
                        // ---> End Log

                        const months = Object.keys(monthlyData).sort();
                        const monthlyAverages = months.map(month => monthlyData[month].sum / monthlyData[month].count);

                        const monthLabels = months.map(monthYear => {
                            // ---> Add Log: Check month label generation
                            const [year, month] = monthYear.split('-');
                            // Use UTC for consistency when creating label date, month is 1-based here
                            const date = new Date(Date.UTC(parseInt(year), parseInt(month) - 1, 1));
                            const label = date.toLocaleDateString('en-US', { month: 'short', year: 'numeric', timeZone: 'UTC' }); // Force UTC display
                            console.log(`DEBUG: Generating label for ${monthYear}, Result: ${label}`);
                            // ---> End Log
                            return label;
                        });
                
                // Create chart container
                const chartDiv = document.createElement('div');
                chartDiv.style.width = '100%';
                chartDiv.style.maxWidth = '800px';
                chartDiv.style.margin = '20px auto';
                chartContainer.appendChild(chartDiv);
                
                const canvas = document.createElement('canvas');
                chartDiv.appendChild(canvas);
                
                // Get colors based on AQI levels by converting concentration to AQI first
                const colors = monthlyAverages.map(value => {
                    // Convert concentration to AQI first, then determine color
                    const aqi = convertToAQI(value, parameter);
                    
                    // Return color based on AQI
                    if (aqi <= 50) return '#00e400';          // Good
                    else if (aqi <= 100) return '#ffff00';    // Moderate
                    else if (aqi <= 150) return '#ff7e00';    // Unhealthy for Sensitive Groups
                    else if (aqi <= 200) return '#ff0000';    // Unhealthy
                    else if (aqi <= 300) return '#99004c';    // Very Unhealthy
                    else return '#7e0023';                    // Hazardous
                });
                
                // Define concentration thresholds for reference lines
                let goodThreshold, moderateThreshold, unhealthySensitiveThreshold;
                
                switch(parameter) {
                    case 'OZONE':
                    case 'OZONE-8HR':
                        // ppb - FIXED THRESHOLDS
                        goodThreshold = 54;              // Good/Moderate boundary (AQI 50/51)
                        moderateThreshold = 71;          // Moderate/USG boundary (AQI 100/101) - FIXED from 70 to 71
                        unhealthySensitiveThreshold = 85; // USG/Unhealthy boundary (AQI 150/151)
                        break;
                        
                    case 'PM2.5':
                    case 'PM2.5-24hr':
                        // g/m - Updated with new standards
                        goodThreshold = 9.0;               // Good/Moderate boundary (AQI 50/51)
                        moderateThreshold = 35.4;          // Moderate/USG boundary (AQI 100/101)
                        unhealthySensitiveThreshold = 55.4; // USG/Unhealthy boundary (AQI 150/151)
                        break;
                        
                    case 'PM10':
                    case 'PM10-24hr':
                        // g/m
                        goodThreshold = 54;
                        moderateThreshold = 154;
                        unhealthySensitiveThreshold = 254;
                        break;
                        
                    case 'NO2':
                        // ppb
                        goodThreshold = 53;
                        moderateThreshold = 100;
                        unhealthySensitiveThreshold = 360;
                        break;
                        
                    case 'SO2':
                    case 'SO2-24HR':
                        // ppb
                        goodThreshold = 35;
                        moderateThreshold = 75;
                        unhealthySensitiveThreshold = 185;
                        break;
                        
                    case 'CO':
                    case 'CO-8hr':
                        // ppm
                        goodThreshold = 4.4;
                        moderateThreshold = 9.4;
                        unhealthySensitiveThreshold = 12.4;
                        break;
                        
                    default:
                        // Default thresholds
                        goodThreshold = 50;
                        moderateThreshold = 100;
                        unhealthySensitiveThreshold = 150;
                }
                
                // Create the chart
                const ctx = canvas.getContext('2d');
                const chart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: monthLabels,
                        datasets: [{
                            label: `${parameter} Monthly Average (${units})`,
                            data: monthlyAverages,
                            backgroundColor: colors,
                            borderColor: '#333',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            title: {
                                display: true,
                                text: `${parameter} Monthly Averages for ${area}`,
                                font: {
                                    size: 16,
                                    weight: 'bold'
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    afterLabel: function(context) {
                                        const value = context.raw;
                                        const aqi = convertToAQI(value, parameter);
                                        return [
                                            `Concentration: ${value.toFixed(2)} ${units}`,
                                            `AQI: ${aqi}`,
                                            `Category: ${getAQICategory(aqi)}`
                                        ];
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: `${parameter} Value (${units})`
                                }
                            }
                        }
                    }
                });
                
                charts.push(chart);
                
                // Add reference lines for threshold values
                if (chart.config && chart.config.options && chart.config.options.scales && chart.config.options.scales.y) {
                    // Add horizontal line annotations for the AQI thresholds
                    chart.config.options.plugins = chart.config.options.plugins || {};
                    chart.config.options.plugins.annotation = {
                        annotations: {
                            goodLine: {
                                type: 'line',
                                yMin: goodThreshold,
                                yMax: goodThreshold,
                                borderColor: '#ffff00', // Yellow for Moderate threshold
                                borderWidth: 2,
                                borderDash: [5, 5],
                                label: {
                                    enabled: true,
                                    content: `Good/Moderate (${goodThreshold} ${units})`,
                                    position: 'end'
                                }
                            },
                            moderateLine: {
                                type: 'line',
                                yMin: moderateThreshold,
                                yMax: moderateThreshold,
                                borderColor: '#ff7e00', // Orange for USG threshold
                                borderWidth: 2,
                                borderDash: [5, 5],
                                label: {
                                    enabled: true,
                                    content: `Moderate/USG (${moderateThreshold} ${units})`,
                                    position: 'end'
                                }
                            }
                        }
                    };
                    
                    // Force chart update
                    chart.update();
                }
                
                // Add a legend explaining colors
                addChartLegend(chartDiv, parameter);
                
                // Add explanation about concentration vs AQI
                const noteDiv = document.createElement('div');
                noteDiv.style.margin = '10px auto';
                noteDiv.style.maxWidth = '800px';
                noteDiv.style.padding = '10px';
                noteDiv.style.backgroundColor = '#f8f9fa';
                noteDiv.style.border = '1px solid #ddd';
                noteDiv.style.borderRadius = '5px';
                noteDiv.style.fontSize = '0.9rem';
                noteDiv.innerHTML = `
                    <p><strong>Note:</strong> Values shown are in concentration units (${units}), but colors represent AQI categories.</p>
                    <p><strong>${parameter} Concentration Thresholds:</strong></p>
                    <ul style="margin-top: 5px; padding-left: 20px;">
                        <li>Good (Green):  ${goodThreshold} ${units}</li>
                        <li>Moderate (Yellow): ${goodThreshold+1} - ${moderateThreshold-1} ${units}</li>
                        <li>Unhealthy for Sensitive Groups (Orange): ${moderateThreshold} - ${unhealthySensitiveThreshold} ${units}</li>
                        <li>Unhealthy (Red): > ${unhealthySensitiveThreshold} ${units}</li>
                    </ul>
                `;
                chartDiv.appendChild(noteDiv);
            });
        }

            // Updated function for multi-pollutant comparison
            function displayPollutantComparison(data, area, selectedPollutants) {
                clearCharts();
                
                // Hide containers for other analysis types
                document.getElementById('exceedance-summary').style.display = 'none';
                document.getElementById('statistical-summary').style.display = 'none';
                
                // Filter for selected pollutants and remove OZONE-1HR
                const filteredData = data.filter(entry => 
                    selectedPollutants.includes(entry.parameter) && 
                    entry.parameter !== 'OZONE-1HR'
                );
                
                if (filteredData.length === 0 || selectedPollutants.length === 0) {
                    chartContainer.innerHTML = '<p>No data available for the selected pollutants. Please select at least one pollutant.</p>';
                    return;
                }
                
                // Normalize data for better comparison
                const normalizedData = normalizeData(filteredData, selectedPollutants);
                
                // Group by date to align data points
                const dateGroups = {};
                normalizedData.forEach(entry => {
                    const dateStr = entry.date;
                    if (!dateGroups[dateStr]) {
                        dateGroups[dateStr] = {};
                    }
                    // Use normalized values for chart
                    dateGroups[dateStr][entry.parameter] = entry.normalizedValue;
                });
                
                // Convert to format for Chart.js
                const dates = Object.keys(dateGroups).sort();
                
                // Create chart container
                const chartDiv = document.createElement('div');
                chartDiv.style.width = '100%';
                chartDiv.style.maxWidth = '900px';
                chartDiv.style.margin = '20px auto';
                chartContainer.appendChild(chartDiv);
                
                const canvas = document.createElement('canvas');
                chartDiv.appendChild(canvas);
                
                // Format dates for display
                const formattedDates = dates.map(dateStr => {
                    const date = new Date(dateStr);
                    return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                });
                
                // Create datasets for each pollutant (excluding OZONE-1HR)
                const actualPollutants = [...new Set(filteredData.map(item => item.parameter))];
                
                const datasets = actualPollutants.map((pollutant, index) => {
                    // Assign different colors to each pollutant
                    const colors = [
                        'rgba(0, 123, 255, 0.8)',    // Blue
                        'rgba(220, 53, 69, 0.8)',    // Red
                        'rgba(40, 167, 69, 0.8)',    // Green
                        'rgba(255, 193, 7, 0.8)',    // Yellow
                        'rgba(111, 66, 193, 0.8)',   // Purple
                        'rgba(23, 162, 184, 0.8)'    // Teal
                    ];
                    
                    const values = dates.map(date => dateGroups[date][pollutant] || null);
                    
                    return {
                        label: `${pollutant} (normalized to AQI scale)`,
                        data: values,
                        borderColor: colors[index % colors.length],
                        backgroundColor: colors[index % colors.length].replace('0.8', '0.1'),
                        borderWidth: 2,
                        pointRadius: 3,
                        fill: false
                    };
                });
                
                // Create the chart
                const ctx = canvas.getContext('2d');
                const chart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: formattedDates,
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            title: {
                                display: true,
                                text: `Multi-Pollutant Comparison for ${area} (Normalized to AQI Scale)`,
                                font: {
                                    size: 16,
                                    weight: 'bold'
                                }
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                callbacks: {
                                    afterLabel: function(context) {
                                        const parameter = actualPollutants[context.datasetIndex];
                                        const dateStr = dates[context.dataIndex];
                                        
                                        // Find the original data point using the correct date format
                                        const originalPoint = filteredData.find(item => 
                                            item.parameter === parameter && 
                                            item.date === dateStr
                                        );
                                        
                                        if (originalPoint) {
                                            const units = getUnitsForParameter(parameter);
                                            return [
                                                `Original value: ${originalPoint.value} ${units}`,
                                                `AQI: ${convertToAQI(parseFloat(originalPoint.value), parameter)}`
                                            ];
                                        }
                                        return '';
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 45
                                }
                            },
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Normalized AQI Value (0-500 scale)'
                                },
                                suggestedMax: 150  // Set a reasonable default max
                            }
                        }
                    }
                });
                
                charts.push(chart);
                
                // Add explanation about normalization
                const noteDiv = document.createElement('div');
                noteDiv.style.margin = '10px auto';
                noteDiv.style.maxWidth = '900px';
                noteDiv.style.padding = '10px';
                noteDiv.style.backgroundColor = '#f8f9fa';
                noteDiv.style.border = '1px solid #ddd';
                noteDiv.style.borderRadius = '5px';
                noteDiv.innerHTML = `
                    <p><strong>Normalized Comparison:</strong> Different pollutants use different measurement units, so 
                    values have been converted to the AQI scale (0-500) for comparison:</p>
                    <ul style="margin-top: 5px;">
                        ${actualPollutants.map(parameter => {
                            return `<li><strong>${parameter}:</strong> Original values in ${getUnitsForParameter(parameter)}, 
                                    converted to AQI scale using EPA breakpoints</li>`;
                        }).join('')}
                    </ul>
                    <p style="margin-top: 5px;"><strong>AQI Categories:</strong></p>
                    <div style="display: flex; flex-wrap: wrap; margin-top: 5px;">
                        <div style="display: flex; align-items: center; margin-right: 15px; margin-bottom: 5px;">
                            <span style="display: inline-block; width: 15px; height: 15px; background-color: #00e400; margin-right: 5px;"></span>
                            <span>Good (0-50)</span>
                        </div>
                        <div style="display: flex; align-items: center; margin-right: 15px; margin-bottom: 5px;">
                            <span style="display: inline-block; width: 15px; height: 15px; background-color: #ffff00; margin-right: 5px;"></span>
                            <span>Moderate (51-100)</span>
                        </div>
                        <div style="display: flex; align-items: center; margin-right: 15px; margin-bottom: 5px;">
                            <span style="display: inline-block; width: 15px; height: 15px; background-color: #ff7e00; margin-right: 5px;"></span>
                            <span>Unhealthy for Sensitive Groups (101-150)</span>
                        </div>
                        <div style="display: flex; align-items: center; margin-right: 15px; margin-bottom: 5px;">
                            <span style="display: inline-block; width: 15px; height: 15px; background-color: #ff0000; margin-right: 5px;"></span>
                            <span>Unhealthy (151-200)</span>
                        </div>
                    </div>
                `;
                chartContainer.appendChild(noteDiv);
            }

            // Function to normalize concentration data to AQI scale for comparison
            function normalizeData(data, selectedPollutants) {
                return data.map(entry => {
                    // Convert the concentration value to AQI
                    const value = parseFloat(entry.value);
                    const aqi = convertToAQI(value, entry.parameter);
                    
                    // Return a new object with the original data plus the normalized value
                    return {
                        ...entry,
                        normalizedValue: aqi
                    };
                });
            }

        // Updated function for statistical summary with concentration values
        function displayStatisticalSummary(data, area) {
            // Clear previous charts
            clearCharts();
            
            // Hide exceedance summary
            document.getElementById('exceedance-summary').style.display = 'none';
            
            // Show statistical summary
            const statisticalSummary = document.getElementById('statistical-summary');
            statisticalSummary.style.display = 'block';
            const statisticsContent = document.getElementById('statistics-content');
            
            // Group data by parameter and filter out OZONE-1HR
            const parameterGroups = {};
            data.forEach(entry => {
                // Skip OZONE-1HR data
                if (entry.parameter === 'OZONE-1HR') {
                    return;
                }
                
                if (!parameterGroups[entry.parameter]) {
                    parameterGroups[entry.parameter] = [];
                }
                parameterGroups[entry.parameter].push(entry);
            });
            
            let summaryHTML = '';
            
            // Calculate statistics for each parameter
            Object.keys(parameterGroups).forEach(parameter => {
                const parameterData = parameterGroups[parameter];
                const values = parameterData.map(d => parseFloat(d.value)).filter(v => !isNaN(v));
                
                if (values.length === 0) {
                    summaryHTML += `<p>No valid data for ${parameter}</p>`;
                    return;
                }
                
                // Get units for this parameter
                const units = getUnitsForParameter(parameter);
                
                // Sort values for percentile calculations
                values.sort((a, b) => a - b);
                
                // Calculate basic statistics
                const min = values[0];
                const max = values[values.length - 1];
                const sum = values.reduce((a, b) => a + b, 0);
                const avg = sum / values.length;
                
                // Calculate median
                let median;
                if (values.length % 2 === 0) {
                    median = (values[values.length / 2 - 1] + values[values.length / 2]) / 2;
                } else {
                    median = values[Math.floor(values.length / 2)];
                }
                
                // Calculate 90th percentile
                const p90Index = Math.floor(values.length * 0.9);
                const p90 = values[p90Index];
                
                // Define concentration thresholds based on parameter
                let goodThreshold, moderateThreshold, unhealthySensitiveThreshold;
                
                switch(parameter) {
                    case 'OZONE':
                    case 'OZONE-8HR':
                        // ppb - FIXED THRESHOLDS
                        goodThreshold = 54;              // Good/Moderate boundary (AQI 50/51)
                        moderateThreshold = 71;          // Moderate/USG boundary (AQI 100/101) - FIXED from 70 to 71
                        unhealthySensitiveThreshold = 85; // USG/Unhealthy boundary (AQI 150/151)
                        break;
                        
                    case 'PM2.5':
                    case 'PM2.5-24hr':
                        // g/m - Updated with new standards
                        goodThreshold = 9.0;               // Good/Moderate boundary (AQI 50/51)
                        moderateThreshold = 35.4;          // Moderate/USG boundary (AQI 100/101)
                        unhealthySensitiveThreshold = 55.4; // USG/Unhealthy boundary (AQI 150/151)
                        break;
                        
                    case 'PM10':
                    case 'PM10-24hr':
                        // g/m
                        goodThreshold = 54;
                        moderateThreshold = 154;
                        unhealthySensitiveThreshold = 254;
                        break;
                        
                    case 'NO2':
                        // ppb
                        goodThreshold = 53;
                        moderateThreshold = 100;
                        unhealthySensitiveThreshold = 360;
                        break;
                        
                    case 'SO2':
                    case 'SO2-24HR':
                        // ppb
                        goodThreshold = 35;
                        moderateThreshold = 75;
                        unhealthySensitiveThreshold = 185;
                        break;
                        
                    case 'CO':
                    case 'CO-8hr':
                        // ppm
                        goodThreshold = 4.4;
                        moderateThreshold = 9.4;
                        unhealthySensitiveThreshold = 12.4;
                        break;
                        
                    default:
                        // Default thresholds
                        goodThreshold = 50;
                        moderateThreshold = 100;
                        unhealthySensitiveThreshold = 150;
                }
                
                // Count days in each category
                const goodDays = values.filter(v => v <= goodThreshold).length;
                const moderateDays = values.filter(v => v > goodThreshold && v <= moderateThreshold).length;
                const unhealthySensitiveDays = values.filter(v => v > moderateThreshold && v <= unhealthySensitiveThreshold).length;
                const unhealthyDays = values.filter(v => v > unhealthySensitiveThreshold).length;
                
                // Create HTML for this parameter's statistics
                summaryHTML += `
                    <div class="parameter-statistics" style="margin-bottom: 30px;">
                        <h4>${parameter} Statistical Summary for ${area}</h4>
                        <div style="padding: 8px; background-color: #f8f9fa; border-radius: 5px; margin-bottom: 15px;">
                            <strong>Values shown in ${parameter} concentration (${units})</strong>
                        </div>
                        <div class="stats-grid" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin-bottom: 20px;">
                            <div class="stat-card" style="background-color: #f8f9fa; padding: 10px; border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                                <div style="font-weight: bold;">Minimum</div>
                                <div style="font-size: 1.2rem;">${min.toFixed(2)} ${units}</div>
                            </div>
                            <div class="stat-card" style="background-color: #f8f9fa; padding: 10px; border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                                <div style="font-weight: bold;">Maximum</div>
                                <div style="font-size: 1.2rem;">${max.toFixed(2)} ${units}</div>
                            </div>
                            <div class="stat-card" style="background-color: #f8f9fa; padding: 10px; border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                                <div style="font-weight: bold;">Average</div>
                                <div style="font-size: 1.2rem;">${avg.toFixed(2)} ${units}</div>
                            </div>
                            <div class="stat-card" style="background-color: #f8f9fa; padding: 10px; border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                                <div style="font-weight: bold;">Median</div>
                                <div style="font-size: 1.2rem;">${median.toFixed(2)} ${units}</div>
                            </div>
                            <div class="stat-card" style="background-color: #f8f9fa; padding: 10px; border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                                <div style="font-weight: bold;">90th Percentile</div>
                                <div style="font-size: 1.2rem;">${p90.toFixed(2)} ${units}</div>
                            </div>
                            <div class="stat-card" style="background-color: #f8f9fa; padding: 10px; border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                                <div style="font-weight: bold;">Total Days</div>
                                <div style="font-size: 1.2rem;">${values.length}</div>
                            </div>
                        </div>
                        
                        <h5>Air Quality Categories</h5>
                        <div style="margin-bottom: 10px; font-size: 0.9rem;">
                            <strong>Category Thresholds for ${parameter}:</strong><br>
                             Good:  ${goodThreshold} ${units}<br>
                             Moderate: ${goodThreshold+1} - ${moderateThreshold-1} ${units}<br>
                             Unhealthy for Sensitive Groups: ${moderateThreshold} - ${unhealthySensitiveThreshold} ${units}<br>
                             Unhealthy: > ${unhealthySensitiveThreshold} ${units}
                        </div>
                        
                        <div class="category-bars" style="margin-top: 15px;">
                            <div class="category-label">Good: ${goodDays} days (${(goodDays/values.length*100).toFixed(1)}%)</div>
                            <div class="category-bar" style="background-color: #00e400; height: 20px; width: ${(goodDays/values.length*100).toFixed(1)}%; margin-bottom: 5px;"></div>
                            
                            <div class="category-label">Moderate: ${moderateDays} days (${(moderateDays/values.length*100).toFixed(1)}%)</div>
                            <div class="category-bar" style="background-color: #ffff00; height: 20px; width: ${(moderateDays/values.length*100).toFixed(1)}%; margin-bottom: 5px;"></div>
                            
                            <div class="category-label">Unhealthy for Sensitive Groups: ${unhealthySensitiveDays} days (${(unhealthySensitiveDays/values.length*100).toFixed(1)}%)</div>
                            <div class="category-bar" style="background-color: #ff7e00; height: 20px; width: ${(unhealthySensitiveDays/values.length*100).toFixed(1)}%; margin-bottom: 5px;"></div>
                            
                            <div class="category-label">Unhealthy: ${unhealthyDays} days (${(unhealthyDays/values.length*100).toFixed(1)}%)</div>
                            <div class="category-bar" style="background-color: #ff0000; height: 20px; width: ${(unhealthyDays/values.length*100).toFixed(1)}%; margin-bottom: 5px;"></div>
                        </div>
                    </div>
                `;
                
                // Create chart container
                const chartDiv = document.createElement('div');
                chartDiv.style.width = '100%';
                chartDiv.style.maxWidth = '800px';
                chartDiv.style.margin = '20px auto';
                chartContainer.appendChild(chartDiv);
                
                const canvas = document.createElement('canvas');
                chartDiv.appendChild(canvas);
                
                // Create data for monthly averages and maxes
                const monthlyData = {};
                parameterData.forEach(entry => {
                    const entryDateStr = entry.date; // Should be "YYYY-MM-DD" from filtered data
                    // Create Date object at local noon to avoid timezone shifts at midnight
                    const date = new Date(entryDateStr + 'T12:00:00');
                    const year = date.getFullYear();
                    const month = date.getMonth(); // 0-indexed
                    const monthYear = `${year}-${String(month + 1).padStart(2, '0')}`; // YYYY-MM

                    if (!monthlyData[monthYear]) {
                        monthlyData[monthYear] = { values: [], dates: [] };
                    }
                    // Ensure value is a number before pushing
                    const value = parseFloat(entry.value);
                    if (!isNaN(value)) {
                         monthlyData[monthYear].values.push(value);
                    }
                    monthlyData[monthYear].dates.push(date); // Store the noon date object
                });
                
                // Sort months
                const months = Object.keys(monthlyData).sort();
                
                // Format month labels consistently
                const monthLabels = months.map(monthYear => {
                    const [year, month] = monthYear.split('-');
                    // Use UTC for consistency when creating label date, month is 1-based here
                    const date = new Date(Date.UTC(parseInt(year), parseInt(month) - 1, 1));
                    // Force UTC display for label to avoid local timezone interpretation
                    return date.toLocaleDateString('en-US', { month: 'short', year: 'numeric', timeZone: 'UTC' });
                });
                
                // Calculate monthly averages and max values
                const monthlyAverages = months.map(month => {
                    const monthValues = monthlyData[month].values;
                    return monthValues.reduce((a, b) => a + b, 0) / monthValues.length;
                });
                
                const monthlyMaxValues = months.map(month => {
                    const monthValues = monthlyData[month].values;
                    return Math.max(...monthValues);
                });
                
                // Create the chart
                const ctx = canvas.getContext('2d');
                const chart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: monthLabels,
                        datasets: [
                            {
                                label: `Monthly Average (${units})`,
                                data: monthlyAverages,
                                backgroundColor: 'rgba(0, 123, 255, 0.6)',
                                borderColor: 'rgba(0, 123, 255, 1)',
                                borderWidth: 1
                            },
                            {
                                label: `Monthly Maximum (${units})`,
                                data: monthlyMaxValues,
                                backgroundColor: 'rgba(220, 53, 69, 0.6)',
                                borderColor: 'rgba(220, 53, 69, 1)',
                                borderWidth: 1
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            title: {
                                display: true,
                                text: `${parameter} Monthly Statistics for ${area}`,
                                font: {
                                    size: 16,
                                    weight: 'bold'
                                }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: `${parameter} Value (${units})`
                                }
                            }
                        }
                    }
                });
                
                charts.push(chart);
                
                // Add reference lines for thresholds
                if (chart.config && chart.config.options && chart.config.options.scales && chart.config.options.scales.y) {
                    // Add horizontal line annotations for the thresholds
                    chart.config.options.plugins = chart.config.options.plugins || {};
                    chart.config.options.plugins.annotation = {
                        annotations: {
                            goodLine: {
                                type: 'line',
                                yMin: goodThreshold,
                                yMax: goodThreshold,
                                borderColor: '#ffff00', // Yellow for Moderate threshold
                                borderWidth: 2,
                                borderDash: [5, 5],
                                label: {
                                    enabled: true,
                                    content: 'Good/Moderate',
                                    position: 'end'
                                }
                            },
                            moderateLine: {
                                type: 'line',
                                yMin: moderateThreshold,
                                yMax: moderateThreshold,
                                borderColor: '#ff7e00', // Orange for USG threshold
                                borderWidth: 2,
                                borderDash: [5, 5],
                                label: {
                                    enabled: true,
                                    content: 'Moderate/USG',
                                    position: 'end'
                                }
                            }
                        }
                    };
                    
                    // Force chart update
                    chart.update();
                }
            });
            
            // Display the summary HTML
            statisticsContent.innerHTML = summaryHTML;
        }
        
        // Helper function to add a legend to charts
        function addChartLegend(chartDiv, parameter) {
            const legendDiv = document.createElement('div');
            legendDiv.style.display = 'flex';
            legendDiv.style.flexWrap = 'wrap';
            legendDiv.style.justifyContent = 'center';
            legendDiv.style.margin = '10px auto';
            legendDiv.style.maxWidth = '800px';
            chartDiv.appendChild(legendDiv);
            
            // Create a small legend with actual colors (not CSS variables)
            const categories = [
                { name: 'Good (0-50)', color: '#00e400' },
                { name: 'Moderate (51-100)', color: '#ffff00' },
                { name: 'Unhealthy for Sensitive Groups (101-150)', color: '#ff7e00' },
                { name: 'Unhealthy (151-200)', color: '#ff0000' },
                { name: 'Very Unhealthy (201-300)', color: '#99004c' },
                { name: 'Hazardous (301+)', color: '#7e0023' }
            ];
            
            categories.forEach(category => {
                const item = document.createElement('div');
                item.style.display = 'flex';
                item.style.alignItems = 'center';
                item.style.margin = '3px 8px';
                
                const colorBox = document.createElement('span');
                colorBox.style.width = '15px';
                colorBox.style.height = '15px';
                colorBox.style.backgroundColor = category.color;
                colorBox.style.display = 'inline-block';
                colorBox.style.marginRight = '5px';
                
                const name = document.createElement('span');
                name.textContent = category.name;
                name.style.fontSize = '0.75rem';
                
                item.appendChild(colorBox);
                item.appendChild(name);
                legendDiv.appendChild(item);
            });
        }

        // This is a placeholder function that simulates fetching historical data
        async function fetchSampleData(area, startDate, endDate) {
            // In a real implementation, you would fetch data from your API
            // This is just a sample implementation that returns dummy data
            
            const cacheKey = `historical_${area}_${startDate}_${endDate}`;
            
            if (apiCache[cacheKey]) {
                return apiCache[cacheKey];
            }
            
            // Simulate data fetching delay
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // Convert dates to Date objects if they're strings
            const start = typeof startDate === 'string' ? new Date(startDate) : new Date(startDate);
            const end = typeof endDate === 'string' ? new Date(endDate) : new Date(endDate);
            
            // Generate date range
            const dateRange = [];
            for (let date = new Date(start); date <= end; date.setDate(date.getDate() + 1)) {
                dateRange.push(new Date(date).toISOString().split('T')[0]);
            }
            
            // Generate sample data for different parameters
            const parameters = ['OZONE', 'PM2.5', 'PM10', 'NO2', 'SO2', 'CO'];
            const results = [];
            
            dateRange.forEach(date => {
                parameters.forEach(parameter => {
                    // Generate realistic base values for each parameter
                    let baseValue;
                    switch (parameter) {
                        case 'OZONE':
                            baseValue = 40 + Math.random() * 30; // typically 40-70 ppb
                            break;
                        case 'PM2.5':
                            baseValue = 8 + Math.random() * 20;  // typically 8-28 g/m
                            break;
                        case 'PM10':
                            baseValue = 20 + Math.random() * 40; // typically 20-60 g/m
                            break;
                        case 'NO2':
                            baseValue = 10 + Math.random() * 30; // typically 10-40 ppb
                            break;
                        case 'SO2':
                            baseValue = 2 + Math.random() * 10;  // typically 2-12 ppb
                            break;
                        case 'CO':
                            baseValue = 0.4 + Math.random() * 1; // typically 0.4-1.4 ppm
                            break;
                        default:
                            baseValue = 30 + Math.random() * 40;
                    }
                    
                    // Add seasonal variations
                    const dateObj = new Date(date);
                    const month = dateObj.getMonth();
                    
                    // Ozone is higher in summer months
                    if (parameter === 'OZONE' && (month >= 4 && month <= 8)) {
                        baseValue *= 1.3;
                    }
                    
                    // PM2.5 can be higher in winter
                    if (parameter === 'PM2.5' && (month <= 1 || month >= 10)) {
                        baseValue *= 1.2;
                    }
                    
                    // Add random spikes occasionally
                    if (Math.random() < 0.05) {
                        baseValue *= 1.5 + Math.random();
                    }
                    
                    results.push({
                        date: date,
                        parameter: parameter,
                        value: baseValue.toFixed(1),
                        area: area
                    });
                });
            });
            
            // Cache the results
            apiCache[cacheKey] = results;
            
            return results;
        }
    </script>
    \ No newline at end of file
    </body>
</html>
